-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ§  UNIVERSAL ROBLOX GAME ANALYZER v3.0 - GUARANTEED WORK
-- 
-- NEW SYSTEM:
-- âœ… LOCAL Tab - Exploit yang PASTI WORK (Values, Clicks, Prompts)
-- âš ï¸ REMOTE Tab - Exploit Advanced yang BUTUH SKILL
-- ğŸ¯ Smart categorization based on what ACTUALLY works
-- ğŸ“ Value Editor - Edit values sebelum execute
-- ğŸ“– Clear descriptions - Tau ini untuk apa
-- 
-- DELTA ANDROID OPTIMIZED - 100% WORKING EXPLOITS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local version = "3.1.0-GUARANTEED"
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("ğŸ§  UNIVERSAL GAME ANALYZER v" .. version)
print("ğŸ“± Delta Android | ğŸ’¯ Guaranteed Working Exploits")
print("ğŸ“‹ NEW: Copy & Edit Script Features!")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

wait(0.3)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SERVICES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Services = {
    Players = game:GetService("Players"),
    RS = game:GetService("ReplicatedStorage"),
    WS = game:GetService("Workspace"),
    CoreGui = game:GetService("CoreGui"),
    TweenService = game:GetService("TweenService"),
    HttpService = game:GetService("HttpService"),
    MarketplaceService = game:GetService("MarketplaceService"),
    UIS = game:GetService("UserInputService")
}

local player = Services.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local camera = workspace.CurrentCamera

-- Device detection
local isMobile = Services.UIS.TouchEnabled
local screenSize = camera.ViewportSize

print("ğŸ“± Device: " .. (isMobile and "Mobile" or "PC"))
print("ğŸ“ Screen: " .. math.floor(screenSize.X) .. "x" .. math.floor(screenSize.Y))

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CORE ANALYZER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Analyzer = {
    Version = version,
    
    -- State
    IsScanning = false,
    CurrentTab = "Dashboard",
    
    -- Data
    ScanData = {
        Total = 0,
        Scanned = 0,
        StartTime = 0,
        Duration = 0
    },
    
    GameInfo = {
        Name = "Unknown Game",
        PlaceId = game.PlaceId,
        Genre = "ğŸ® Unknown"
    },
    
    -- Categorized by RELIABILITY
    Exploits = {
        Local = {},      -- 100% Work - Values, Clicks, etc
        Remote = {},     -- Risky - Need parameters
        Automation = {}, -- Click/Prompt automation
    },
    
    -- Deep Scan Results
    DeepScan = {
        Scripts = {},           -- Script, ModuleScript, Actor
        ServerServices = {},    -- ServerScriptService, ServerStorage, etc
        RemoteCommunication = {}, -- RemoteEvent, RemoteFunction, etc
        InstanceChanges = {},   -- Instance creation, property changes
        Physics = {},           -- Network ownership, anchored parts
        PlayerManagement = {},  -- PlayerAdded, Kick, etc
        Security = {},          -- GamePass, DevProduct, anti-cheat
        WorldState = {},        -- Leaderboard, game state, timer
        AnimationSound = {},    -- Animator, Sound
        Constraints = {},       -- WeldConstraint, Motor6D, etc
        Collections = {},       -- CollectionService tags
        GlobalState = {},       -- _G, shared, values
    },
    
    -- Generated Scripts
    Scripts = {},
    
    -- Active Loops
    ActiveLoops = {},
    
    -- Smart AI Scripts
    SmartScripts = {},
    GamePatterns = {},
    
    -- Settings
    Settings = {
        ShowNotifs = true,
        AutoClickSpeed = 0.1,
        LoopEnabled = false
    }
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UTILITY FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function SafeCall(func, ...)
    local success, result = pcall(func, ...)
    return success, result
end

local function GetPath(obj)
    local success, path = SafeCall(function() return obj:GetFullName() end)
    return success and path or "Unknown"
end

local function CountObjects(container)
    local count = 0
    SafeCall(function()
        for _, obj in pairs(container:GetDescendants()) do
            count = count + 1
        end
    end)
    return count
end

local function IsClientEditable(obj)
    -- Check if value can be edited from client
    if not obj:IsA("ValueBase") then return false end
    
    local path = GetPath(obj)
    
    -- Values in these locations are usually client-editable
    if path:match("^Players%.") and path:match("PlayerGui") then
        return true
    end
    if path:match("^Players%.") and not path:match("Backpack") then
        return true
    end
    
    -- Try to edit and see if it works
    local originalValue = obj.Value
    local success = false
    
    SafeCall(function()
        local testValue
        local valueType = obj.ClassName
        
        if valueType == "NumberValue" or valueType == "IntValue" or valueType == "DoubleValue" then
            testValue = originalValue + 1
        elseif valueType == "StringValue" then
            testValue = originalValue .. "_test"
        elseif valueType == "BoolValue" then
            testValue = not originalValue
        else
            testValue = originalValue
        end
        
        obj.Value = testValue
        wait(0.1)
        
        if obj.Value == testValue then
            success = true
        end
        
        obj.Value = originalValue
    end)
    
    return success
end

local function IsNumericValue(obj)
    -- Check if this is a numeric value type
    local valueType = obj.ClassName
    return valueType == "NumberValue" or valueType == "IntValue" or valueType == "DoubleValue"
end

local function CanExecuteValue(exploit)
    -- Determine if this value can be executed/injected into the game
    -- Even if read-only, some values might affect game when triggered
    local name = exploit.Name:lower()
    
    -- Values that typically affect gameplay when modified
    local gameplayKeywords = {
        "speed", "walk", "jump", "health", "damage", "power",
        "enable", "active", "unlock", "complete", "finish",
        "premium", "vip", "admin", "owner", "mod"
    }
    
    for _, keyword in ipairs(gameplayKeywords) do
        if name:match(keyword) then
            return true
        end
    end
    
    -- If it's editable, it can be executed
    if exploit.IsEditable then
        return true
    end
    
    return false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GAME DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function Analyzer:DetectGame()
    print("\nğŸ” Detecting game type...")
    
    SafeCall(function()
        local info = Services.MarketplaceService:GetProductInfo(game.PlaceId)
        self.GameInfo.Name = info.Name or "Unknown Game"
    end)
    
    local name = self.GameInfo.Name:lower()
    
    local genres = {
        {patterns = {"fish", "fishing", "rod"}, icon = "ğŸ£", name = "Fishing"},
        {patterns = {"farm", "plant", "harvest", "crop"}, icon = "ğŸŒ¾", name = "Farming"},
        {patterns = {"mine", "dig", "ore", "pickaxe"}, icon = "â›ï¸", name = "Mining"},
        {patterns = {"fight", "combat", "battle", "box", "arena"}, icon = "ğŸ¥Š", name = "Fighting"},
        {patterns = {"tycoon", "factory", "build"}, icon = "ğŸ­", name = "Tycoon"},
        {patterns = {"simulator", "sim"}, icon = "ğŸ®", name = "Simulator"},
        {patterns = {"obby", "parkour", "tower"}, icon = "ğŸƒ", name = "Obby"},
        {patterns = {"pet", "adopt"}, icon = "ğŸ¾", name = "Pet"},
        {patterns = {"race", "racing", "drive"}, icon = "ğŸï¸", name = "Racing"}
    }
    
    for _, genre in ipairs(genres) do
        for _, pattern in ipairs(genre.patterns) do
            if name:match(pattern) then
                self.GameInfo.Genre = genre.icon .. " " .. genre.name
                print("âœ… Detected: " .. self.GameInfo.Genre)
                return
            end
        end
    end
    
    print("â„¹ï¸ Genre: Unknown")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SMART ANALYZER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function Analyzer:StartScan()
    if self.IsScanning then
        self:Notify("âš ï¸ Warning", "Already scanning!")
        return
    end
    
    self.IsScanning = true
    self:ResetData()
    self.ScanData.StartTime = tick()
    
    self:Notify("ğŸ” Scanner", "Starting intelligent scan...")
    
    spawn(function()
        print("\nğŸ“Š Counting objects...")
        local containers = {
            {obj = Services.WS, name = "Workspace"},
            {obj = Services.RS, name = "ReplicatedStorage"},
            {obj = playerGui, name = "PlayerGui"},
            {obj = player, name = "Player"}
        }
        
        for _, container in ipairs(containers) do
            self.ScanData.Total = self.ScanData.Total + CountObjects(container.obj)
        end
        
        print("ğŸ“Š Total to scan: " .. self.ScanData.Total)
        
        if GUI_UpdateProgress then
            GUI_UpdateProgress(0, self.ScanData.Total)
        end
        
        for _, container in ipairs(containers) do
            print("\nğŸ” Scanning " .. container.name .. "...")
            self:ScanContainer(container.obj, container.name)
        end
        
        self.ScanData.Duration = tick() - self.ScanData.StartTime
        self.IsScanning = false
        
        self:CategorizeExploits()
        
        -- AI Game Logic Analysis
        self:AnalyzeGameLogic()
        self:GenerateSmartAutomation()
        
        print("\nâœ… Scan complete!")
        print("â±ï¸ Duration: " .. math.floor(self.ScanData.Duration) .. "s")
        print("ğŸ“Š Objects scanned: " .. self.ScanData.Scanned)
        print("ğŸ’¯ Local exploits: " .. #self.Exploits.Local)
        print("âš ï¸ Remote exploits: " .. #self.Exploits.Remote)
        print("ğŸ¤– Automation: " .. #self.Exploits.Automation)
        
        self:Notify("âœ… Complete!", string.format("Found %d local + %d remote exploits", 
            #self.Exploits.Local, #self.Exploits.Remote))
        
        if GUI_UpdateResults then
            GUI_UpdateResults()
        end
    end)
end

function Analyzer:ScanContainer(container, name)
    SafeCall(function()
        local descendants = container:GetDescendants()
        
        for _, obj in ipairs(descendants) do
            self.ScanData.Scanned = self.ScanData.Scanned + 1
            
            if self.ScanData.Scanned % 100 == 0 then
                if GUI_UpdateProgress then
                    GUI_UpdateProgress(self.ScanData.Scanned, self.ScanData.Total)
                end
                wait()
            end
            
            -- Analyze each object
            self:AnalyzeObject(obj)
        end
    end)
end

function Analyzer:AnalyzeObject(obj)
    SafeCall(function()
        local objType = obj.ClassName
        local objName = obj.Name
        local objPath = GetPath(obj)
        
        -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        -- DEEP SCAN - Advanced Object Detection
        -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        -- Script Types
        if objType == "Script" or objType == "LocalScript" then
            table.insert(self.DeepScan.Scripts, {
                Type = "Script",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ“œ",
                Description = objType .. " - " .. (obj.Disabled and "Disabled" or "Enabled"),
                Category = "Scripts"
            })
        end
        
        if objType == "ModuleScript" then
            table.insert(self.DeepScan.Scripts, {
                Type = "ModuleScript",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ“¦",
                Description = "ModuleScript - Can be required",
                Category = "Scripts"
            })
        end
        
        if objType == "Actor" then
            table.insert(self.DeepScan.Scripts, {
                Type = "Actor",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ­",
                Description = "Actor - Parallel Lua container",
                Category = "Scripts"
            })
        end
        
        -- Remote Communication
        if objType == "RemoteEvent" then
            table.insert(self.DeepScan.RemoteCommunication, {
                Type = "RemoteEvent",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ“¡",
                Description = "RemoteEvent - Client-Server communication",
                Category = "Remote"
            })
        end
        
        if objType == "RemoteFunction" then
            table.insert(self.DeepScan.RemoteCommunication, {
                Type = "RemoteFunction",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ“",
                Description = "RemoteFunction - Request-Response pattern",
                Category = "Remote"
            })
        end
        
        if objType == "UnreliableRemoteEvent" then
            table.insert(self.DeepScan.RemoteCommunication, {
                Type = "UnreliableRemoteEvent",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ“¶",
                Description = "UnreliableRemoteEvent - Fast but may drop",
                Category = "Remote"
            })
        end
        
        if objType == "BindableEvent" then
            table.insert(self.DeepScan.RemoteCommunication, {
                Type = "BindableEvent",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ”—",
                Description = "BindableEvent - Script-to-Script communication",
                Category = "Remote"
            })
        end
        
        if objType == "BindableFunction" then
            table.insert(self.DeepScan.RemoteCommunication, {
                Type = "BindableFunction",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "âš™ï¸",
                Description = "BindableFunction - Script callback",
                Category = "Remote"
            })
        end
        
        -- Constraints & Mechanical
        local constraintTypes = {
            "WeldConstraint", "Motor6D", "HingeConstraint", "RopeConstraint",
            "SpringConstraint", "AlignPosition", "AlignOrientation",
            "BodyVelocity", "BodyForce", "BodyGyro", "BodyPosition",
            "LinearVelocity", "AngularVelocity", "VectorForce", "Torque",
            "BallSocketConstraint", "PrismaticConstraint", "CylindricalConstraint",
            "RodConstraint", "Weld", "ManualWeld", "Snap", "Glue"
        }
        
        for _, constraintType in ipairs(constraintTypes) do
            if objType == constraintType then
                table.insert(self.DeepScan.Constraints, {
                    Type = constraintType,
                    Name = objName,
                    Path = objPath,
                    Object = obj,
                    Icon = "ğŸ”§",
                    Description = constraintType .. " - Physics constraint",
                    Category = "Constraints"
                })
                break
            end
        end
        
        -- Animation & Sound
        if objType == "Animator" then
            table.insert(self.DeepScan.AnimationSound, {
                Type = "Animator",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ¬",
                Description = "Animator - Animation controller",
                Category = "Animation"
            })
        end
        
        if objType == "Animation" then
            table.insert(self.DeepScan.AnimationSound, {
                Type = "Animation",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸï¸",
                Description = "Animation - AnimationId: " .. tostring(obj.AnimationId):sub(1, 30),
                Category = "Animation"
            })
        end
        
        if objType == "Sound" then
            table.insert(self.DeepScan.AnimationSound, {
                Type = "Sound",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ”Š",
                Description = string.format("Sound - Volume: %.1f, Playing: %s", obj.Volume, tostring(obj.Playing)),
                Category = "Sound"
            })
        end
        
        -- World State objects
        if objType == "IntValue" or objType == "NumberValue" or objType == "StringValue" or objType == "BoolValue" then
            local pathLower = objPath:lower()
            if pathLower:match("leaderstats") or pathLower:match("stats") then
                table.insert(self.DeepScan.WorldState, {
                    Type = "Leaderboard",
                    Name = objName,
                    Path = objPath,
                    Object = obj,
                    Icon = "ğŸ†",
                    Description = "Leaderboard stat: " .. tostring(obj.Value),
                    Category = "WorldState"
                })
            end
        end
        
        -- Check Values (LOCAL - Process ALL value types)
        if objType:match("Value") then
            local nameLower = objName:lower()
            
            -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            -- MEGA KEYWORD DATABASE - Covers ALL Game Types
            -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            local isRelevant = 
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- CURRENCY & ECONOMY (50+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("money") or nameLower:match("cash") or nameLower:match("coin") or 
                nameLower:match("gold") or nameLower:match("gem") or nameLower:match("crystal") or
                nameLower:match("diamond") or nameLower:match("ruby") or nameLower:match("token") or
                nameLower:match("credit") or nameLower:match("dollar") or nameLower:match("currency") or
                nameLower:match("wealth") or nameLower:match("balance") or nameLower:match("bank") or
                nameLower:match("emerald") or nameLower:match("sapphire") or nameLower:match("pearl") or
                nameLower:match("robux") or nameLower:match("ticket") or nameLower:match("star") or
                nameLower:match("medal") or nameLower:match("trophy") or nameLower:match("badge") or
                nameLower:match("voucher") or nameLower:match("coupon") or nameLower:match("fragment") or
                nameLower:match("shard") or nameLower:match("essence") or nameLower:match("soul") or
                nameLower:match("orb") or nameLower:match("rune") or nameLower:match("dust") or
                nameLower:match("powder") or nameLower:match("material") or nameLower:match("resource") or
                nameLower:match("supply") or nameLower:match("stock") or nameLower:match("fund") or
                nameLower:match("treasure") or nameLower:match("loot") or nameLower:match("bounty") or
                nameLower:match("prize") or nameLower:match("jackpot") or nameLower:match("payout") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- PROGRESSION & LEVELS (40+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("level") or nameLower:match("xp") or nameLower:match("exp") or
                nameLower:match("point") or nameLower:match("score") or nameLower:match("rank") or
                nameLower:match("tier") or nameLower:match("prestige") or nameLower:match("rebirth") or
                nameLower:match("stage") or nameLower:match("progress") or nameLower:match("advancement") or
                nameLower:match("ascend") or nameLower:match("evolve") or nameLower:match("upgrade") or
                nameLower:match("enhance") or nameLower:match("improve") or nameLower:match("growth") or
                nameLower:match("chapter") or nameLower:match("world") or nameLower:match("zone") or
                nameLower:match("area") or nameLower:match("region") or nameLower:match("realm") or
                nameLower:match("dimension") or nameLower:match("floor") or nameLower:match("wave") or
                nameLower:match("round") or nameLower:match("phase") or nameLower:match("milestone") or
                nameLower:match("achievement") or nameLower:match("trophy") or nameLower:match("star") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- STATS & ATTRIBUTES (60+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("speed") or nameLower:match("walk") or nameLower:match("run") or
                nameLower:match("sprint") or nameLower:match("dash") or nameLower:match("velocity") or
                nameLower:match("jump") or nameLower:match("leap") or nameLower:match("bounce") or
                nameLower:match("health") or nameLower:match("hp") or nameLower:match("life") or
                nameLower:match("heart") or nameLower:match("vitality") or nameLower:match("constitution") or
                nameLower:match("damage") or nameLower:match("power") or nameLower:match("strength") or
                nameLower:match("attack") or nameLower:match("atk") or nameLower:match("force") or
                nameLower:match("defense") or nameLower:match("armor") or nameLower:match("shield") or
                nameLower:match("def") or nameLower:match("resistance") or nameLower:match("protection") or
                nameLower:match("stamina") or nameLower:match("energy") or nameLower:match("mana") or
                nameLower:match("mp") or nameLower:match("magic") or nameLower:match("chakra") or
                nameLower:match("agility") or nameLower:match("dexterity") or nameLower:match("luck") or
                nameLower:match("crit") or nameLower:match("critical") or nameLower:match("accuracy") or
                nameLower:match("evasion") or nameLower:match("dodge") or nameLower:match("block") or
                nameLower:match("parry") or nameLower:match("penetration") or nameLower:match("pierce") or
                nameLower:match("regen") or nameLower:match("heal") or nameLower:match("recovery") or
                nameLower:match("lifesteal") or nameLower:match("vampirism") or nameLower:match("leech") or
                nameLower:match("range") or nameLower:match("reach") or nameLower:match("radius") or
                nameLower:match("cooldown") or nameLower:match("cd") or nameLower:match("recharge") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- FISHING GAMES (30+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("fish") or nameLower:match("rod") or nameLower:match("bait") or
                nameLower:match("catch") or nameLower:match("reel") or nameLower:match("hook") or
                nameLower:match("cast") or nameLower:match("bite") or nameLower:match("lure") or
                nameLower:match("tackle") or nameLower:match("bobber") or nameLower:match("sinker") or
                nameLower:match("net") or nameLower:match("trap") or nameLower:match("aquarium") or
                nameLower:match("pond") or nameLower:match("lake") or nameLower:match("ocean") or
                nameLower:match("river") or nameLower:match("stream") or nameLower:match("boat") or
                nameLower:match("shark") or nameLower:match("whale") or nameLower:match("salmon") or
                nameLower:match("tuna") or nameLower:match("crab") or nameLower:match("lobster") or
                nameLower:match("shrimp") or nameLower:match("squid") or nameLower:match("octopus") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- FARMING GAMES (40+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("farm") or nameLower:match("crop") or nameLower:match("seed") or
                nameLower:match("plant") or nameLower:match("harvest") or nameLower:match("water") or
                nameLower:match("grow") or nameLower:match("plot") or nameLower:match("soil") or
                nameLower:match("fertilizer") or nameLower:match("compost") or nameLower:match("barn") or
                nameLower:match("silo") or nameLower:match("tractor") or nameLower:match("plow") or
                nameLower:match("wheat") or nameLower:match("corn") or nameLower:match("carrot") or
                nameLower:match("potato") or nameLower:match("tomato") or nameLower:match("apple") or
                nameLower:match("orange") or nameLower:match("berry") or nameLower:match("grape") or
                nameLower:match("melon") or nameLower:match("pumpkin") or nameLower:match("sunflower") or
                nameLower:match("tree") or nameLower:match("orchard") or nameLower:match("greenhouse") or
                nameLower:match("sprinkler") or nameLower:match("scarecrow") or nameLower:match("fence") or
                nameLower:match("animal") or nameLower:match("chicken") or nameLower:match("cow") or
                nameLower:match("pig") or nameLower:match("sheep") or nameLower:match("horse") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- MINING GAMES (35+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("mine") or nameLower:match("ore") or nameLower:match("pickaxe") or
                nameLower:match("stone") or nameLower:match("rock") or nameLower:match("mineral") or
                nameLower:match("dig") or nameLower:match("excavate") or nameLower:match("drill") or
                nameLower:match("coal") or nameLower:match("iron") or nameLower:match("copper") or
                nameLower:match("silver") or nameLower:match("platinum") or nameLower:match("titanium") or
                nameLower:match("uranium") or nameLower:match("obsidian") or nameLower:match("bedrock") or
                nameLower:match("cave") or nameLower:match("tunnel") or nameLower:match("shaft") or
                nameLower:match("vein") or nameLower:match("deposit") or nameLower:match("layer") or
                nameLower:match("depth") or nameLower:match("underground") or nameLower:match("quarry") or
                nameLower:match("dynamite") or nameLower:match("tnt") or nameLower:match("explosive") or
                nameLower:match("cart") or nameLower:match("rail") or nameLower:match("conveyor") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- PET GAMES (40+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("pet") or nameLower:match("egg") or nameLower:match("hatch") or
                nameLower:match("adopt") or nameLower:match("breed") or nameLower:match("evolve") or
                nameLower:match("rare") or nameLower:match("legendary") or nameLower:match("mythic") or
                nameLower:match("epic") or nameLower:match("common") or nameLower:match("uncommon") or
                nameLower:match("shiny") or nameLower:match("golden") or nameLower:match("rainbow") or
                nameLower:match("neon") or nameLower:match("mega") or nameLower:match("fly") or
                nameLower:match("ride") or nameLower:match("mount") or nameLower:match("companion") or
                nameLower:match("familiar") or nameLower:match("summon") or nameLower:match("tame") or
                nameLower:match("feed") or nameLower:match("treat") or nameLower:match("food") or
                nameLower:match("hunger") or nameLower:match("happiness") or nameLower:match("mood") or
                nameLower:match("loyalty") or nameLower:match("bond") or nameLower:match("affection") or
                nameLower:match("dragon") or nameLower:match("unicorn") or nameLower:match("phoenix") or
                nameLower:match("griffin") or nameLower:match("wolf") or nameLower:match("cat") or
                nameLower:match("dog") or nameLower:match("bunny") or nameLower:match("bird") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- FIGHTING/COMBAT GAMES (50+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("fight") or nameLower:match("battle") or nameLower:match("combat") or
                nameLower:match("attack") or nameLower:match("hit") or nameLower:match("kill") or
                nameLower:match("weapon") or nameLower:match("sword") or nameLower:match("gun") or
                nameLower:match("knife") or nameLower:match("axe") or nameLower:match("bow") or
                nameLower:match("arrow") or nameLower:match("spear") or nameLower:match("staff") or
                nameLower:match("wand") or nameLower:match("hammer") or nameLower:match("mace") or
                nameLower:match("dagger") or nameLower:match("katana") or nameLower:match("scythe") or
                nameLower:match("pistol") or nameLower:match("rifle") or nameLower:match("shotgun") or
                nameLower:match("sniper") or nameLower:match("smg") or nameLower:match("lmg") or
                nameLower:match("grenade") or nameLower:match("rocket") or nameLower:match("missile") or
                nameLower:match("ammo") or nameLower:match("bullet") or nameLower:match("clip") or
                nameLower:match("magazine") or nameLower:match("reload") or nameLower:match("aim") or
                nameLower:match("scope") or nameLower:match("silencer") or nameLower:match("attachment") or
                nameLower:match("combo") or nameLower:match("special") or nameLower:match("ultimate") or
                nameLower:match("finisher") or nameLower:match("execution") or nameLower:match("fatality") or
                nameLower:match("ko") or nameLower:match("knockout") or nameLower:match("stun") or
                nameLower:match("freeze") or nameLower:match("burn") or nameLower:match("poison") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- TYCOON GAMES (40+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("tycoon") or nameLower:match("factory") or nameLower:match("produce") or
                nameLower:match("build") or nameLower:match("upgrade") or nameLower:match("income") or
                nameLower:match("profit") or nameLower:match("revenue") or nameLower:match("business") or
                nameLower:match("company") or nameLower:match("enterprise") or nameLower:match("corporation") or
                nameLower:match("employee") or nameLower:match("worker") or nameLower:match("manager") or
                nameLower:match("ceo") or nameLower:match("boss") or nameLower:match("owner") or
                nameLower:match("machine") or nameLower:match("conveyor") or nameLower:match("dropper") or
                nameLower:match("furnace") or nameLower:match("upgrader") or nameLower:match("rebirth") or
                nameLower:match("prestige") or nameLower:match("automation") or nameLower:match("passive") or
                nameLower:match("multiplier") or nameLower:match("boost") or nameLower:match("efficiency") or
                nameLower:match("production") or nameLower:match("output") or nameLower:match("capacity") or
                nameLower:match("storage") or nameLower:match("warehouse") or nameLower:match("depot") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- RACING GAMES (35+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("race") or nameLower:match("car") or nameLower:match("vehicle") or
                nameLower:match("nitro") or nameLower:match("boost") or nameLower:match("lap") or
                nameLower:match("track") or nameLower:match("circuit") or nameLower:match("drift") or
                nameLower:match("turbo") or nameLower:match("engine") or nameLower:match("wheel") or
                nameLower:match("tire") or nameLower:match("brake") or nameLower:match("accelerate") or
                nameLower:match("gear") or nameLower:match("transmission") or nameLower:match("suspension") or
                nameLower:match("aerodynamic") or nameLower:match("spoiler") or nameLower:match("exhaust") or
                nameLower:match("fuel") or nameLower:match("gas") or nameLower:match("pit") or
                nameLower:match("checkpoint") or nameLower:match("finish") or nameLower:match("podium") or
                nameLower:match("motorcycle") or nameLower:match("bike") or nameLower:match("truck") or
                nameLower:match("bus") or nameLower:match("plane") or nameLower:match("helicopter") or
                nameLower:match("boat") or nameLower:match("jet") or nameLower:match("rocket") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- RPG/ADVENTURE GAMES (45+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("quest") or nameLower:match("mission") or nameLower:match("task") or
                nameLower:match("objective") or nameLower:match("goal") or nameLower:match("story") or
                nameLower:match("campaign") or nameLower:match("adventure") or nameLower:match("journey") or
                nameLower:match("dungeon") or nameLower:match("boss") or nameLower:match("enemy") or
                nameLower:match("monster") or nameLower:match("creature") or nameLower:match("npc") or
                nameLower:match("dialogue") or nameLower:match("cutscene") or nameLower:match("cinematic") or
                nameLower:match("hero") or nameLower:match("villain") or nameLower:match("character") or
                nameLower:match("class") or nameLower:match("warrior") or nameLower:match("mage") or
                nameLower:match("archer") or nameLower:match("rogue") or nameLower:match("healer") or
                nameLower:match("tank") or nameLower:match("support") or nameLower:match("dps") or
                nameLower:match("party") or nameLower:match("guild") or nameLower:match("clan") or
                nameLower:match("alliance") or nameLower:match("faction") or nameLower:match("team") or
                nameLower:match("inventory") or nameLower:match("item") or nameLower:match("loot") or
                nameLower:match("drop") or nameLower:match("chest") or nameLower:match("treasure") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- SURVIVAL GAMES (35+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("survive") or nameLower:match("survival") or nameLower:match("hunger") or
                nameLower:match("thirst") or nameLower:match("food") or nameLower:match("water") or
                nameLower:match("shelter") or nameLower:match("base") or nameLower:match("camp") or
                nameLower:match("craft") or nameLower:match("recipe") or nameLower:match("blueprint") or
                nameLower:match("wood") or nameLower:match("metal") or nameLower:match("cloth") or
                nameLower:match("leather") or nameLower:match("scrap") or nameLower:match("component") or
                nameLower:match("temperature") or nameLower:match("cold") or nameLower:match("hot") or
                nameLower:match("radiation") or nameLower:match("infection") or nameLower:match("disease") or
                nameLower:match("zombie") or nameLower:match("undead") or nameLower:match("infected") or
                nameLower:match("safe") or nameLower:match("danger") or nameLower:match("threat") or
                nameLower:match("night") or nameLower:match("day") or nameLower:match("weather") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- BUILDING/SANDBOX GAMES (30+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("build") or nameLower:match("place") or nameLower:match("destroy") or
                nameLower:match("block") or nameLower:match("brick") or nameLower:match("part") or
                nameLower:match("model") or nameLower:match("structure") or nameLower:match("construction") or
                nameLower:match("foundation") or nameLower:match("wall") or nameLower:match("floor") or
                nameLower:match("roof") or nameLower:match("door") or nameLower:match("window") or
                nameLower:match("stair") or nameLower:match("ramp") or nameLower:match("platform") or
                nameLower:match("decoration") or nameLower:match("furniture") or nameLower:match("paint") or
                nameLower:match("color") or nameLower:match("material") or nameLower:match("texture") or
                nameLower:match("size") or nameLower:match("scale") or nameLower:match("rotate") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- SIMULATOR GAMES (40+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("simulator") or nameLower:match("sim") or nameLower:match("click") or
                nameLower:match("tap") or nameLower:match("idle") or nameLower:match("afk") or
                nameLower:match("auto") or nameLower:match("collect") or nameLower:match("gather") or
                nameLower:match("size") or nameLower:match("giant") or nameLower:match("huge") or
                nameLower:match("mega") or nameLower:match("super") or nameLower:match("ultra") or
                nameLower:match("max") or nameLower:match("limit") or nameLower:match("cap") or
                nameLower:match("storage") or nameLower:match("capacity") or nameLower:match("bag") or
                nameLower:match("backpack") or nameLower:match("pocket") or nameLower:match("slot") or
                nameLower:match("sell") or nameLower:match("shop") or nameLower:match("store") or
                nameLower:match("vendor") or nameLower:match("merchant") or nameLower:match("trade") or
                nameLower:match("exchange") or nameLower:match("convert") or nameLower:match("transform") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- OBBY/PARKOUR GAMES (25+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("obby") or nameLower:match("parkour") or nameLower:match("tower") or
                nameLower:match("climb") or nameLower:match("obstacle") or nameLower:match("checkpoint") or
                nameLower:match("respawn") or nameLower:match("death") or nameLower:match("fall") or
                nameLower:match("skip") or nameLower:match("stage") or nameLower:match("difficulty") or
                nameLower:match("easy") or nameLower:match("medium") or nameLower:match("hard") or
                nameLower:match("extreme") or nameLower:match("impossible") or nameLower:match("insane") or
                nameLower:match("gravity") or nameLower:match("double") or nameLower:match("triple") or
                nameLower:match("coil") or nameLower:match("grapple") or nameLower:match("swing") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- HORROR GAMES (20+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("horror") or nameLower:match("scary") or nameLower:match("fear") or
                nameLower:match("monster") or nameLower:match("ghost") or nameLower:match("demon") or
                nameLower:match("hide") or nameLower:match("seek") or nameLower:match("chase") or
                nameLower:match("escape") or nameLower:match("survive") or nameLower:match("sanity") or
                nameLower:match("flashlight") or nameLower:match("battery") or nameLower:match("key") or
                nameLower:match("door") or nameLower:match("lock") or nameLower:match("puzzle") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- SOCIAL/ROLEPLAY GAMES (25+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("roleplay") or nameLower:match("rp") or nameLower:match("job") or
                nameLower:match("career") or nameLower:match("profession") or nameLower:match("salary") or
                nameLower:match("house") or nameLower:match("home") or nameLower:match("apartment") or
                nameLower:match("rent") or nameLower:match("buy") or nameLower:match("own") or
                nameLower:match("family") or nameLower:match("friend") or nameLower:match("relationship") or
                nameLower:match("marry") or nameLower:match("wedding") or nameLower:match("party") or
                nameLower:match("chat") or nameLower:match("emote") or nameLower:match("dance") or
                nameLower:match("outfit") or nameLower:match("clothing") or nameLower:match("accessory") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- STATUS & UNLOCKS (30+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("unlock") or nameLower:match("lock") or nameLower:match("enable") or
                nameLower:match("disable") or nameLower:match("active") or nameLower:match("inactive") or
                nameLower:match("complete") or nameLower:match("finish") or nameLower:match("done") or
                nameLower:match("achieve") or nameLower:match("claim") or nameLower:match("redeem") or
                nameLower:match("collect") or nameLower:match("obtain") or nameLower:match("acquire") or
                nameLower:match("discover") or nameLower:match("explore") or nameLower:match("find") or
                nameLower:match("open") or nameLower:match("close") or nameLower:match("toggle") or
                nameLower:match("switch") or nameLower:match("change") or nameLower:match("set") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- PREMIUM FEATURES (25+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("premium") or nameLower:match("vip") or nameLower:match("pro") or
                nameLower:match("plus") or nameLower:match("elite") or nameLower:match("deluxe") or
                nameLower:match("exclusive") or nameLower:match("limited") or nameLower:match("special") or
                nameLower:match("admin") or nameLower:match("owner") or nameLower:match("mod") or
                nameLower:match("developer") or nameLower:match("staff") or nameLower:match("creator") or
                nameLower:match("gamepass") or nameLower:match("pass") or nameLower:match("product") or
                nameLower:match("purchase") or nameLower:match("bought") or nameLower:match("owned") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- INVENTORY & EQUIPMENT (35+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("inventory") or nameLower:match("item") or nameLower:match("tool") or
                nameLower:match("equip") or nameLower:match("gear") or nameLower:match("backpack") or
                nameLower:match("slot") or nameLower:match("storage") or nameLower:match("container") or
                nameLower:match("chest") or nameLower:match("box") or nameLower:match("crate") or
                nameLower:match("locker") or nameLower:match("safe") or nameLower:match("vault") or
                nameLower:match("helmet") or nameLower:match("armor") or nameLower:match("boots") or
                nameLower:match("gloves") or nameLower:match("ring") or nameLower:match("amulet") or
                nameLower:match("necklace") or nameLower:match("cape") or nameLower:match("wings") or
                nameLower:match("hat") or nameLower:match("mask") or nameLower:match("face") or
                nameLower:match("skin") or nameLower:match("costume") or nameLower:match("outfit") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- TIME & COOLDOWNS (25+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("time") or nameLower:match("cooldown") or nameLower:match("wait") or
                nameLower:match("duration") or nameLower:match("timer") or nameLower:match("delay") or
                nameLower:match("countdown") or nameLower:match("remaining") or nameLower:match("left") or
                nameLower:match("second") or nameLower:match("minute") or nameLower:match("hour") or
                nameLower:match("day") or nameLower:match("week") or nameLower:match("month") or
                nameLower:match("reset") or nameLower:match("refresh") or nameLower:match("update") or
                nameLower:match("spawn") or nameLower:match("respawn") or nameLower:match("interval") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- MULTIPLIERS & BOOSTS (25+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("multiplier") or nameLower:match("multi") or nameLower:match("boost") or
                nameLower:match("bonus") or nameLower:match("buff") or nameLower:match("debuff") or
                nameLower:match("modifier") or nameLower:match("enhance") or nameLower:match("amplify") or
                nameLower:match("increase") or nameLower:match("decrease") or nameLower:match("double") or
                nameLower:match("triple") or nameLower:match("quadruple") or nameLower:match("percent") or
                nameLower:match("rate") or nameLower:match("chance") or nameLower:match("luck") or
                nameLower:match("fortune") or nameLower:match("blessing") or nameLower:match("curse") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- EVENTS & SEASONS (25+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("event") or nameLower:match("season") or nameLower:match("daily") or
                nameLower:match("weekly") or nameLower:match("monthly") or nameLower:match("reward") or
                nameLower:match("login") or nameLower:match("streak") or nameLower:match("consecutive") or
                nameLower:match("christmas") or nameLower:match("halloween") or nameLower:match("easter") or
                nameLower:match("summer") or nameLower:match("winter") or nameLower:match("spring") or
                nameLower:match("autumn") or nameLower:match("fall") or nameLower:match("anniversary") or
                nameLower:match("birthday") or nameLower:match("celebration") or nameLower:match("festival") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- SPECIAL MECHANICS (30+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("spin") or nameLower:match("roll") or nameLower:match("gacha") or
                nameLower:match("luck") or nameLower:match("chance") or nameLower:match("rng") or
                nameLower:match("random") or nameLower:match("lottery") or nameLower:match("wheel") or
                nameLower:match("auto") or nameLower:match("skip") or nameLower:match("instant") or
                nameLower:match("teleport") or nameLower:match("warp") or nameLower:match("portal") or
                nameLower:match("summon") or nameLower:match("spawn") or nameLower:match("create") or
                nameLower:match("delete") or nameLower:match("remove") or nameLower:match("clear") or
                nameLower:match("save") or nameLower:match("load") or nameLower:match("data") or
                nameLower:match("setting") or nameLower:match("config") or nameLower:match("option") or
                
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                -- WINS & COMPETITIVE (20+ keywords)
                -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                nameLower:match("win") or nameLower:match("lose") or nameLower:match("victory") or
                nameLower:match("defeat") or nameLower:match("streak") or nameLower:match("record") or
                nameLower:match("best") or nameLower:match("high") or nameLower:match("top") or
                nameLower:match("leaderboard") or nameLower:match("ranking") or nameLower:match("position") or
                nameLower:match("place") or nameLower:match("first") or nameLower:match("second") or
                nameLower:match("third") or nameLower:match("match") or nameLower:match("game") or
                nameLower:match("round") or nameLower:match("tournament") or nameLower:match("championship")
            
            if isRelevant then
                local isEditable = IsClientEditable(obj)
                local isNumeric = IsNumericValue(obj)
                local currentValue = obj.Value
                
                local exploit = {
                    Type = "Value",
                    Category = "LOCAL",
                    Name = objName,
                    Path = objPath,
                    Object = obj,
                    ValueType = objType,
                    CurrentValue = currentValue,
                    IsEditable = isEditable,
                    IsNumeric = isNumeric,
                    Icon = self:GetValueIcon(objName),
                    Description = self:GenerateValueDescription(objName, currentValue, isEditable, objType),
                    Action = self:GenerateValueAction(objName, isEditable, isNumeric),
                    Reliability = isEditable and "100% WORK" or "READ-ONLY"
                }
                
                table.insert(self.Exploits.Local, exploit)
            end
        end
        
        -- Check ClickDetector (LOCAL - Auto-click)
        if obj:FindFirstChildOfClass("ClickDetector") then
            local clickCode = string.format([[
-- ğŸ–±ï¸ AUTO CLICK SCRIPT
-- Target: %s
-- Path: %s

local isRunning = true
local clickCount = 0
local clickSpeed = 0.1  -- Adjust speed here

-- Find target
local pathParts = string.split("%s", ".")
local current = game
for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current then
    local detector = current:FindFirstChildOfClass("ClickDetector")
    if detector then
        print("âœ… Auto-click started: %s")
        while isRunning do
            pcall(function()
                fireclickdetector(detector)
                clickCount = clickCount + 1
            end)
            wait(clickSpeed)
        end
        print("â¹ï¸ Stopped. Total clicks:", clickCount)
    end
end
]], objName, objPath, objPath, objName)

            local exploit = {
                Type = "ClickDetector",
                Category = "AUTOMATION",
                Name = objName,
                Path = objPath,
                Object = obj,
                Detector = obj:FindFirstChildOfClass("ClickDetector"),
                Icon = "ğŸ–±ï¸",
                Description = "Clickable object that can be auto-farmed",
                Action = "Auto-click this object repeatedly for farming",
                Reliability = "100% WORK",
                IsEditable = false,
                Code = clickCode
            }
            
            table.insert(self.Exploits.Automation, exploit)
        end
        
        -- Check ProximityPrompt (LOCAL - Auto-trigger)
        if obj:FindFirstChildOfClass("ProximityPrompt") then
            local prompt = obj:FindFirstChildOfClass("ProximityPrompt")
            local promptCode = string.format([[
-- âš¡ AUTO PROXIMITY PROMPT SCRIPT
-- Target: %s
-- Path: %s

local isRunning = true
local triggerCount = 0
local triggerSpeed = 0.1  -- Adjust speed here

-- Find target
local pathParts = string.split("%s", ".")
local current = game
for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current then
    local prompt = current:FindFirstChildOfClass("ProximityPrompt")
    if prompt then
        print("âœ… Auto-prompt started: %s")
        while isRunning do
            pcall(function()
                fireproximityprompt(prompt)
                triggerCount = triggerCount + 1
            end)
            wait(triggerSpeed)
        end
        print("â¹ï¸ Stopped. Total triggers:", triggerCount)
    end
end
]], objName, objPath, objPath, objName)

            local exploit = {
                Type = "ProximityPrompt",
                Category = "AUTOMATION",
                Name = objName,
                Path = objPath,
                Object = obj,
                Prompt = prompt,
                Icon = "âš¡",
                Description = "Proximity prompt: " .. (prompt.ObjectText or "Interact"),
                Action = "Auto-trigger this prompt for automation",
                Reliability = "100% WORK",
                IsEditable = false,
                Code = promptCode
            }
            
            table.insert(self.Exploits.Automation, exploit)
        end
        
        -- Check RemoteEvent/Function (REMOTE - Advanced)
        if objType == "RemoteEvent" or objType == "RemoteFunction" then
            local exploit = {
                Type = objType,
                Category = "REMOTE",
                Name = objName,
                Path = objPath,
                Object = obj,
                Icon = "ğŸ“¡",
                Description = self:GenerateRemoteDescription(objName),
                Action = "Server communication - Requires correct parameters",
                Reliability = "ADVANCED - May not work",
                Parameters = self:DetectParameters(objName),
                IsEditable = false
            }
            
            table.insert(self.Exploits.Remote, exploit)
        end
    end)
end

function Analyzer:GetValueIcon(name)
    local n = name:lower()
    if n:match("money") or n:match("cash") or n:match("coin") then return "ğŸ’°" end
    if n:match("gold") then return "ğŸª™" end
    if n:match("level") then return "â­" end
    if n:match("xp") or n:match("exp") then return "ğŸ“Š" end
    if n:match("point") or n:match("score") then return "ğŸ¯" end
    return "ğŸ’"
end

function Analyzer:GenerateValueDescription(name, value, isEditable, valueType)
    local n = name:lower()
    local desc = ""
    local valueStr = tostring(value)
    
    -- Limit string length for display
    if type(value) == "string" and #valueStr > 30 then
        valueStr = valueStr:sub(1, 30) .. "..."
    end
    
    if n:match("money") or n:match("cash") then
        desc = "ğŸ’° Money/Cash: " .. valueStr
    elseif n:match("coin") then
        desc = "ğŸª™ Coins: " .. valueStr
    elseif n:match("gold") then
        desc = "ğŸª™ Gold: " .. valueStr
    elseif n:match("gem") or n:match("crystal") then
        desc = "ğŸ’ Gems/Crystals: " .. valueStr
    elseif n:match("level") then
        desc = "â­ Level: " .. valueStr
    elseif n:match("xp") or n:match("exp") then
        desc = "ğŸ“Š Experience: " .. valueStr
    elseif n:match("point") or n:match("score") then
        desc = "ğŸ¯ Points/Score: " .. valueStr
    elseif n:match("speed") or n:match("walk") then
        desc = "ğŸƒ Speed/Walk: " .. valueStr
    elseif n:match("jump") then
        desc = "â¬†ï¸ Jump Power: " .. valueStr
    elseif n:match("health") then
        desc = "â¤ï¸ Health: " .. valueStr
    elseif n:match("damage") or n:match("power") then
        desc = "âš”ï¸ Damage/Power: " .. valueStr
    elseif n:match("enable") or n:match("active") then
        desc = "ğŸ”˜ Status: " .. valueStr
    elseif n:match("unlock") then
        desc = "ğŸ”“ Unlocked: " .. valueStr
    elseif n:match("premium") or n:match("vip") then
        desc = "ğŸ‘‘ Premium/VIP: " .. valueStr
    elseif n:match("admin") then
        desc = "âš¡ Admin: " .. valueStr
    elseif n:match("complete") or n:match("finish") then
        desc = "âœ… Completion: " .. valueStr
    elseif n:match("rebirth") or n:match("prestige") then
        desc = "ğŸ”„ Rebirth/Prestige: " .. valueStr
    elseif n:match("rank") or n:match("tier") then
        desc = "ğŸ† Rank/Tier: " .. valueStr
    else
        desc = "ğŸ’¾ Value: " .. valueStr
    end
    
    desc = desc .. " | Type: " .. valueType
    
    if isEditable then
        desc = desc .. " âœ… EDITABLE"
    else
        desc = desc .. " âŒ READ-ONLY"
    end
    
    return desc
end

function Analyzer:GenerateValueAction(name, isEditable, isNumeric)
    local n = name:lower()
    
    if isEditable then
        if isNumeric then
            return "Edit the number and click APPLY to change this value"
        else
            return "Try injecting this value - may affect gameplay"
        end
    else
        -- Even if read-only, some values can be injected/triggered
        if n:match("enable") or n:match("active") or n:match("unlock") then
            return "READ-ONLY but try INJECT - may trigger game events"
        elseif n:match("complete") or n:match("finish") then
            return "READ-ONLY but try INJECT - may complete tasks"
        elseif n:match("premium") or n:match("vip") or n:match("admin") then
            return "READ-ONLY but try INJECT - may grant permissions"
        else
            return "READ-ONLY - Server controlled, view info only"
        end
    end
end

function Analyzer:GenerateRemoteDescription(name)
    local n = name:lower()
    
    if n:match("buy") or n:match("purchase") then
        return "ğŸ›’ Shop/Purchase system - Use to buy items"
    elseif n:match("sell") then
        return "ğŸ’¸ Sell items - Converts items to currency"
    elseif n:match("claim") or n:match("reward") then
        return "ğŸ Claim rewards - Get daily/quest rewards"
    elseif n:match("equip") then
        return "âš”ï¸ Equip items - Change equipped gear"
    elseif n:match("upgrade") then
        return "â¬†ï¸ Upgrade system - Improve stats/items"
    elseif n:match("teleport") or n:match("travel") then
        return "ğŸš€ Teleport - Fast travel system"
    elseif n:match("gamepass") or n:match("pass") then
        return "ğŸŸï¸ GamePass - Premium features"
    else
        return "ğŸ“¡ Remote communication - Server interaction"
    end
end

function Analyzer:DetectParameters(name)
    local n = name:lower()
    local params = {}
    
    if n:match("buy") or n:match("purchase") then
        params = {
            {name = "ItemName", type = "string", default = "Item1", desc = "Name or ID of item to buy"},
            {name = "Amount", type = "number", default = 1, desc = "Quantity to purchase"}
        }
    elseif n:match("sell") then
        params = {
            {name = "ItemName", type = "string", default = "All", desc = "Item to sell or 'All'"},
            {name = "Amount", type = "number", default = 1, desc = "Quantity to sell"}
        }
    elseif n:match("claim") then
        params = {
            {name = "RewardType", type = "string", default = "Daily", desc = "Type of reward to claim"}
        }
    elseif n:match("equip") then
        params = {
            {name = "ItemID", type = "string", default = "Tool1", desc = "Item to equip"}
        }
    end
    
    return params
end

function Analyzer:CategorizeExploits()
    print("\nğŸ“‹ Categorizing exploits by reliability...")
    print("ğŸ’¯ Local: " .. #self.Exploits.Local)
    print("ğŸ¤– Automation: " .. #self.Exploits.Automation)
    print("âš ï¸ Remote: " .. #self.Exploits.Remote)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AI GAME LOGIC ANALYZER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function Analyzer:AnalyzeGameLogic()
    print("\nğŸ§  Analyzing game logic patterns...")
    
    self.GamePatterns = {
        IsFishingGame = false,
        IsFarmingGame = false,
        IsMiningGame = false,
        IsTycoonGame = false,
        IsPetGame = false,
        IsFightingGame = false,
        
        -- Detected Mechanics
        HasAutoFarm = false,
        HasClickLoop = false,
        HasRewardClaim = false,
        HasUpgradeSystem = false,
        
        -- Exploit Chains
        FishingChain = {},
        FarmingChain = {},
        MiningChain = {},
        AutoFarmChain = {}
    }
    
    -- Detect game type from exploits
    for _, exploit in ipairs(self.Exploits.Local) do
        local name = exploit.Name:lower()
        
        if name:match("fish") or name:match("rod") or name:match("catch") or name:match("bait") then
            self.GamePatterns.IsFishingGame = true
        end
        if name:match("farm") or name:match("crop") or name:match("harvest") or name:match("plant") then
            self.GamePatterns.IsFarmingGame = true
        end
        if name:match("mine") or name:match("ore") or name:match("pickaxe") or name:match("dig") then
            self.GamePatterns.IsMiningGame = true
        end
        if name:match("tycoon") or name:match("factory") or name:match("income") then
            self.GamePatterns.IsTycoonGame = true
        end
        if name:match("pet") or name:match("egg") or name:match("hatch") then
            self.GamePatterns.IsPetGame = true
        end
    end
    
    -- Detect automation possibilities
    for _, exploit in ipairs(self.Exploits.Automation) do
        local name = exploit.Name:lower()
        
        if name:match("claim") or name:match("reward") or name:match("collect") then
            self.GamePatterns.HasRewardClaim = true
        end
        if name:match("upgrade") or name:match("buy") or name:match("purchase") then
            self.GamePatterns.HasUpgradeSystem = true
        end
    end
    
    -- Detect Remotes that can be chained
    for _, exploit in ipairs(self.Exploits.Remote) do
        local name = exploit.Name:lower()
        
        -- Fishing chain
        if name:match("fish") or name:match("catch") or name:match("reel") then
            table.insert(self.GamePatterns.FishingChain, exploit)
        end
        
        -- Farming chain
        if name:match("plant") or name:match("harvest") or name:match("water") then
            table.insert(self.GamePatterns.FarmingChain, exploit)
        end
        
        -- Mining chain
        if name:match("mine") or name:match("dig") or name:match("collect") then
            table.insert(self.GamePatterns.MiningChain, exploit)
        end
        
        -- Auto-farm possibilities
        if name:match("auto") or name:match("claim") or name:match("collect") then
            table.insert(self.GamePatterns.AutoFarmChain, exploit)
        end
    end
    
    print("ğŸ£ Fishing Game:", self.GamePatterns.IsFishingGame)
    print("ğŸŒ¾ Farming Game:", self.GamePatterns.IsFarmingGame)
    print("â›ï¸ Mining Game:", self.GamePatterns.IsMiningGame)
    print("ğŸ­ Tycoon Game:", self.GamePatterns.IsTycoonGame)
end

function Analyzer:GenerateSmartAutomation()
    print("\nğŸ¤– Generating smart automation scripts...")
    
    self.SmartScripts = {}
    
    -- FISHING AUTOMATION
    if self.GamePatterns.IsFishingGame and #self.GamePatterns.FishingChain > 0 then
        local fishingScript = self:GenerateFishingBot()
        if fishingScript then
            table.insert(self.SmartScripts, fishingScript)
            print("âœ… Generated: Fishing Bot")
        end
    end
    
    -- FARMING AUTOMATION  
    if self.GamePatterns.IsFarmingGame and #self.GamePatterns.FarmingChain > 0 then
        local farmingScript = self:GenerateFarmingBot()
        if farmingScript then
            table.insert(self.SmartScripts, farmingScript)
            print("âœ… Generated: Farming Bot")
        end
    end
    
    -- MINING AUTOMATION
    if self.GamePatterns.IsMiningGame and #self.GamePatterns.MiningChain > 0 then
        local miningScript = self:GenerateMiningBot()
        if miningScript then
            table.insert(self.SmartScripts, miningScript)
            print("âœ… Generated: Mining Bot")
        end
    end
    
    -- UNIVERSAL AUTO-FARM
    if #self.Exploits.Automation > 0 then
        local autoFarmScript = self:GenerateUniversalAutoFarm()
        if autoFarmScript then
            table.insert(self.SmartScripts, autoFarmScript)
            print("âœ… Generated: Universal Auto-Farm")
        end
    end
    
    -- REWARD AUTO-CLAIMER
    if self.GamePatterns.HasRewardClaim then
        local claimScript = self:GenerateRewardClaimer()
        if claimScript then
            table.insert(self.SmartScripts, claimScript)
            print("âœ… Generated: Reward Claimer")
        end
    end
    
    print("ğŸ¤– Total smart scripts:", #self.SmartScripts)
end

function Analyzer:GenerateFishingBot()
    local remotes = self.GamePatterns.FishingChain
    if #remotes == 0 then return nil end
    
    return {
        Name = "ğŸ£ SMART FISHING BOT",
        Category = "Smart Automation",
        Type = "AI Generated",
        Description = "Intelligent fishing bot - Auto cast, detect bite, reel fish",
        Code = string.format([[
-- ğŸ£ SMART FISHING BOT
-- Auto-generated by AI Game Logic Analyzer

local fishingRemotes = {}
local player = game.Players.LocalPlayer

-- Find all fishing-related remotes
for _, remote in pairs(%s) do
    local name = remote.Name:lower()
    if name:match("cast") then fishingRemotes.cast = remote
    elseif name:match("reel") then fishingRemotes.reel = remote
    elseif name:match("catch") then fishingRemotes.catch = remote
    elseif name:match("fish") then fishingRemotes.fish = remote
    end
end

print("ğŸ£ Fishing Bot Started!")
print("Found remotes:", #fishingRemotes)

local fishingActive = true
local fishCaught = 0

-- Main fishing loop
while fishingActive do
    pcall(function()
        -- Try different fishing sequences
        
        -- Method 1: Cast -> Wait -> Reel
        if fishingRemotes.cast and fishingRemotes.reel then
            fishingRemotes.cast:FireServer()
            wait(math.random(2, 5)) -- Wait for bite
            fishingRemotes.reel:FireServer()
            fishCaught = fishCaught + 1
            print("âœ… Fish caught! Total:", fishCaught)
        
        -- Method 2: Direct catch
        elseif fishingRemotes.catch then
            fishingRemotes.catch:FireServer()
            fishCaught = fishCaught + 1
            print("âœ… Fish caught! Total:", fishCaught)
        
        -- Method 3: Generic fish remote
        elseif fishingRemotes.fish then
            fishingRemotes.fish:FireServer()
            fishCaught = fishCaught + 1
            print("âœ… Fish caught! Total:", fishCaught)
        end
    end)
    
    wait(0.5)
end
]], self:SerializeRemotes(remotes))
    }
end

function Analyzer:GenerateFarmingBot()
    local remotes = self.GamePatterns.FarmingChain
    if #remotes == 0 then return nil end
    
    return {
        Name = "ğŸŒ¾ SMART FARMING BOT",
        Category = "Smart Automation",
        Type = "AI Generated",
        Description = "Auto plant, water, harvest crops in optimal sequence",
        Code = [[
-- ğŸŒ¾ SMART FARMING BOT
print("ğŸŒ¾ Farming Bot Started!")

local farmActive = true
local harvestCount = 0

while farmActive do
    pcall(function()
        -- Find all plots
        local plots = workspace:FindFirstChild("Plots") or workspace:FindFirstChild("Farm")
        
        if plots then
            for _, plot in pairs(plots:GetChildren()) do
                -- Auto plant
                if plot:FindFirstChild("Plant") then
                    fireclickdetector(plot.Plant.ClickDetector)
                end
                
                -- Auto water
                if plot:FindFirstChild("Water") then
                    fireclickdetector(plot.Water.ClickDetector)
                end
                
                -- Auto harvest
                if plot:FindFirstChild("Harvest") then
                    fireclickdetector(plot.Harvest.ClickDetector)
                    harvestCount = harvestCount + 1
                    print("âœ… Harvested! Total:", harvestCount)
                end
            end
        end
    end)
    
    wait(1)
end
]]
    }
end

function Analyzer:GenerateMiningBot()
    return {
        Name = "â›ï¸ SMART MINING BOT",
        Category = "Smart Automation",
        Type = "AI Generated",
        Description = "Auto-mine closest ores with optimal pathfinding",
        Code = [[
-- â›ï¸ SMART MINING BOT
print("â›ï¸ Mining Bot Started!")

local player = game.Players.LocalPlayer
local character = player.Character
local humanoid = character:FindFirstChild("Humanoid")
local hrp = character:FindFirstChild("HumanoidRootPart")

local miningActive = true
local oresMined = 0

while miningActive and hrp do
    pcall(function()
        -- Find closest ore
        local closestOre = nil
        local closestDist = math.huge
        
        local ores = workspace:FindFirstChild("Ores") or workspace
        
        for _, obj in pairs(ores:GetDescendants()) do
            if obj.Name:lower():match("ore") or obj.Name:lower():match("rock") or obj.Name:lower():match("stone") then
                local dist = (obj.Position - hrp.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestOre = obj
                end
            end
        end
        
        if closestOre then
            -- Walk to ore
            humanoid:MoveTo(closestOre.Position)
            wait(closestDist / 16) -- Wait to reach
            
            -- Mine ore
            if closestOre:FindFirstChildOfClass("ClickDetector") then
                fireclickdetector(closestOre:FindFirstChildOfClass("ClickDetector"))
            elseif closestOre:FindFirstChildOfClass("ProximityPrompt") then
                fireproximityprompt(closestOre:FindFirstChildOfClass("ProximityPrompt"))
            end
            
            oresMined = oresMined + 1
            print("âœ… Mined ore! Total:", oresMined)
            wait(1)
        end
    end)
    
    wait(0.5)
end
]]
    }
end

function Analyzer:GenerateUniversalAutoFarm()
    return {
        Name = "ğŸ”„ UNIVERSAL AUTO-FARM",
        Category = "Smart Automation",
        Type = "AI Generated",
        Description = "Auto-click ALL clickables and prompts in the game",
        Code = [[
-- ğŸ”„ UNIVERSAL AUTO-FARM
print("ğŸ”„ Universal Auto-Farm Started!")

local autoFarmActive = true
local totalClicks = 0

while autoFarmActive do
    pcall(function()
        -- Auto-click all ClickDetectors
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("ClickDetector") then
                fireclickdetector(obj)
                totalClicks = totalClicks + 1
            end
        end
        
        -- Auto-trigger all ProximityPrompts
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("ProximityPrompt") then
                fireproximityprompt(obj)
                totalClicks = totalClicks + 1
            end
        end
        
        if totalClicks % 100 == 0 then
            print("âœ… Total interactions:", totalClicks)
        end
    end)
    
    wait(0.1)
end
]]
    }
end

function Analyzer:GenerateRewardClaimer()
    return {
        Name = "ğŸ REWARD AUTO-CLAIMER",
        Category = "Smart Automation",
        Type = "AI Generated",
        Description = "Auto-claim all daily, quest, and achievement rewards",
        Code = [[
-- ğŸ REWARD AUTO-CLAIMER
print("ğŸ Reward Claimer Started!")

local claimActive = true
local rewardsClaimed = 0

while claimActive do
    pcall(function()
        -- Find and click all claim buttons
        for _, gui in pairs(game.Players.LocalPlayer.PlayerGui:GetDescendants()) do
            if gui:IsA("TextButton") or gui:IsA("ImageButton") then
                local text = gui.Text:lower()
                if text:match("claim") or text:match("collect") or text:match("reward") then
                    -- Click the button
                    for _, connection in pairs(getconnections(gui.MouseButton1Click)) do
                        connection:Fire()
                        rewardsClaimed = rewardsClaimed + 1
                        print("âœ… Claimed reward! Total:", rewardsClaimed)
                    end
                end
            end
        end
    end)
    
    wait(5) -- Check every 5 seconds
end
]]
    }
end

function Analyzer:SerializeRemotes(remotes)
    local paths = {}
    for _, remote in ipairs(remotes) do
        table.insert(paths, '"' .. remote.Path .. '"')
    end
    return "{" .. table.concat(paths, ", ") .. "}"
end

function Analyzer:ResetData()
    self.ScanData = {
        Total = 0,
        Scanned = 0,
        StartTime = 0,
        Duration = 0
    }
    
    self.Exploits = {
        Local = {},
        Remote = {},
        Automation = {}
    }
    
    -- Reset Deep Scan data
    self.DeepScan = {
        Scripts = {},
        ServerServices = {},
        RemoteCommunication = {},
        InstanceChanges = {},
        Physics = {},
        PlayerManagement = {},
        Security = {},
        WorldState = {},
        AnimationSound = {},
        Constraints = {},
        Collections = {},
        GlobalState = {},
    }
    
    self.Scripts = {}
    self.ActiveLoops = {}
    self.SmartScripts = {}
    self.GamePatterns = {}
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- EXECUTION SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function Analyzer:ExecuteValue(exploit, newValue)
    if not exploit.IsEditable and not CanExecuteValue(exploit) then
        self:Notify("âŒ Error", "This value cannot be modified or injected!")
        return false
    end
    
    local action = exploit.IsEditable and "Modifying" or "Injecting"
    self:Notify("â–¶ï¸ Execute", action .. " " .. exploit.Name)
    
    local success = SafeCall(function()
        local valueToSet = newValue
        
        -- Convert value based on type
        if exploit.ValueType == "NumberValue" or exploit.ValueType == "IntValue" or exploit.ValueType == "DoubleValue" then
            valueToSet = tonumber(newValue)
            if not valueToSet then
                error("Invalid number")
            end
        elseif exploit.ValueType == "BoolValue" then
            if type(newValue) == "boolean" then
                valueToSet = newValue
            elseif type(newValue) == "string" then
                valueToSet = newValue:lower() == "true" or newValue == "1"
            else
                valueToSet = newValue == 1
            end
        elseif exploit.ValueType == "StringValue" then
            valueToSet = tostring(newValue)
        end
        
        exploit.Object.Value = valueToSet
        
        print("âœ… " .. action .. " " .. exploit.Name)
        print("Old value:", exploit.CurrentValue)
        print("New value:", exploit.Object.Value)
        
        -- Fire any changed events
        if exploit.Object:FindFirstChild("Changed") then
            exploit.Object.Changed:Fire(valueToSet)
        end
    end)
    
    if success then
        self:Notify("âœ… Success", exploit.Name .. " = " .. tostring(newValue))
        exploit.CurrentValue = newValue
        return true
    else
        self:Notify("âŒ Failed", "Could not modify/inject value")
        return false
    end
end

function Analyzer:ExecuteAutoClick(exploit)
    local loopId = exploit.Path
    
    if self.ActiveLoops[loopId] then
        -- Stop loop
        self.ActiveLoops[loopId] = false
        self:Notify("â¹ï¸ Stopped", "Auto-click stopped")
        return
    end
    
    -- Start loop
    self.ActiveLoops[loopId] = true
    self:Notify("â–¶ï¸ Started", "Auto-clicking " .. exploit.Name)
    
    spawn(function()
        local clickCount = 0
        while self.ActiveLoops[loopId] do
            SafeCall(function()
                fireclickdetector(exploit.Detector)
                clickCount = clickCount + 1
            end)
            wait(self.Settings.AutoClickSpeed)
        end
        print("âœ… Auto-clicked " .. clickCount .. " times")
    end)
end

function Analyzer:ExecuteProximityPrompt(exploit)
    local loopId = exploit.Path
    
    if self.ActiveLoops[loopId] then
        self.ActiveLoops[loopId] = false
        self:Notify("â¹ï¸ Stopped", "Auto-prompt stopped")
        return
    end
    
    self.ActiveLoops[loopId] = true
    self:Notify("â–¶ï¸ Started", "Auto-triggering " .. exploit.Name)
    
    spawn(function()
        local triggerCount = 0
        while self.ActiveLoops[loopId] do
            SafeCall(function()
                fireproximityprompt(exploit.Prompt)
                triggerCount = triggerCount + 1
            end)
            wait(self.Settings.AutoClickSpeed)
        end
        print("âœ… Auto-triggered " .. triggerCount .. " times")
    end)
end

function Analyzer:ExecuteRemote(exploit, args)
    self:Notify("â–¶ï¸ Execute", "Testing " .. exploit.Name)
    
    spawn(function()
        local testCombinations = {
            {},
            {args[1] or "Item1"},
            {args[1] or "Item1", args[2] or 1},
            {args[1] or "Item1", args[2] or 1, args[3] or 0}
        }
        
        local successCount = 0
        
        for i, testArgs in ipairs(testCombinations) do
            local success, result = SafeCall(function()
                if exploit.Type == "RemoteEvent" then
                    exploit.Object:FireServer(unpack(testArgs))
                else
                    return exploit.Object:InvokeServer(unpack(testArgs))
                end
            end)
            
            if success then
                successCount = successCount + 1
                print(string.format("âœ… Test %d SUCCESS", i))
                if #testArgs > 0 then
                    print("  Args:", table.concat(testArgs, ", "))
                end
            end
            
            wait(0.5)
        end
        
        if successCount > 0 then
            self:Notify("âœ… Partial Success", successCount .. "/4 tests passed")
        else
            self:Notify("âŒ Failed", "All tests failed - wrong parameters")
        end
    end)
end

function Analyzer:StopAll()
    for loopId, _ in pairs(self.ActiveLoops) do
        self.ActiveLoops[loopId] = false
    end
    self:Notify("â¹ï¸ Stopped", "All automation stopped")
end

function Analyzer:Notify(title, text)
    if not self.Settings.ShowNotifs then return end
    
    print(title .. ": " .. text)
    
    if GUI_ShowNotification then
        spawn(function()
            GUI_ShowNotification(title, text)
        end)
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GUI SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ¨ Creating GUI...")

local guiSuccess, guiError = pcall(function()

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "UniversalAnalyzer"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local success = pcall(function()
    ScreenGui.Parent = playerGui
end)

if not success then
    pcall(function()
        ScreenGui.Parent = Services.CoreGui
    end)
end

print("âœ… GUI Parent: " .. tostring(ScreenGui.Parent))

local guiScale = math.min(screenSize.X / 400, screenSize.Y / 700)
guiScale = math.clamp(guiScale, 0.7, 1.2)

-- Main Container
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, math.floor(380 * guiScale), 0, math.floor(650 * guiScale))
MainFrame.Position = UDim2.new(0.5, -math.floor(190 * guiScale), 0.5, -math.floor(325 * guiScale))
MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 28)
MainFrame.BorderSizePixel = 0
MainFrame.ClipsDescendants = true
MainFrame.Active = true
MainFrame.Draggable = true
MainFrame.ZIndex = 1
MainFrame.Parent = ScreenGui

local MainCorner = Instance.new("UICorner")
MainCorner.CornerRadius = UDim.new(0, 16)
MainCorner.Parent = MainFrame

local Gradient = Instance.new("UIGradient")
Gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 42)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 15, 22))
}
Gradient.Rotation = 45
Gradient.Parent = MainFrame

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- SCRIPT EDITOR POPUP
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local EditorFrame = Instance.new("Frame")
EditorFrame.Name = "EditorFrame"
EditorFrame.Size = UDim2.new(0, math.floor(360 * guiScale), 0, math.floor(450 * guiScale))
EditorFrame.Position = UDim2.new(0.5, -math.floor(180 * guiScale), 0.5, -math.floor(225 * guiScale))
EditorFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
EditorFrame.BorderSizePixel = 0
EditorFrame.Visible = false
EditorFrame.Active = true
EditorFrame.Draggable = true
EditorFrame.ZIndex = 50
EditorFrame.Parent = ScreenGui

local EditorCorner = Instance.new("UICorner")
EditorCorner.CornerRadius = UDim.new(0, 12)
EditorCorner.Parent = EditorFrame

local EditorBorder = Instance.new("UIStroke")
EditorBorder.Color = Color3.fromRGB(100, 150, 255)
EditorBorder.Thickness = 2
EditorBorder.Parent = EditorFrame

-- Editor Title Bar
local EditorTitleBar = Instance.new("Frame")
EditorTitleBar.Size = UDim2.new(1, 0, 0, math.floor(40 * guiScale))
EditorTitleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 50)
EditorTitleBar.BorderSizePixel = 0
EditorTitleBar.ZIndex = 51
EditorTitleBar.Parent = EditorFrame

local EditorTitleCorner = Instance.new("UICorner")
EditorTitleCorner.CornerRadius = UDim.new(0, 12)
EditorTitleCorner.Parent = EditorTitleBar

local EditorTitle = Instance.new("TextLabel")
EditorTitle.Size = UDim2.new(1, -60, 1, 0)
EditorTitle.Position = UDim2.new(0, 10, 0, 0)
EditorTitle.BackgroundTransparency = 1
EditorTitle.Text = "âœï¸ SCRIPT EDITOR"
EditorTitle.TextColor3 = Color3.fromRGB(100, 200, 255)
EditorTitle.TextSize = math.floor(14 * guiScale)
EditorTitle.Font = Enum.Font.GothamBold
EditorTitle.TextXAlignment = Enum.TextXAlignment.Left
EditorTitle.ZIndex = 52
EditorTitle.Parent = EditorTitleBar

local EditorCloseBtn = Instance.new("TextButton")
EditorCloseBtn.Size = UDim2.new(0, math.floor(30 * guiScale), 0, math.floor(30 * guiScale))
EditorCloseBtn.Position = UDim2.new(1, -math.floor(35 * guiScale), 0, 5)
EditorCloseBtn.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
EditorCloseBtn.Text = "âœ•"
EditorCloseBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
EditorCloseBtn.TextSize = math.floor(14 * guiScale)
EditorCloseBtn.Font = Enum.Font.GothamBold
EditorCloseBtn.ZIndex = 52
EditorCloseBtn.Parent = EditorTitleBar

local EditorCloseBtnCorner = Instance.new("UICorner")
EditorCloseBtnCorner.CornerRadius = UDim.new(0, 6)
EditorCloseBtnCorner.Parent = EditorCloseBtn

-- Script Name Label
local ScriptNameLabel = Instance.new("TextLabel")
ScriptNameLabel.Size = UDim2.new(1, -20, 0, math.floor(25 * guiScale))
ScriptNameLabel.Position = UDim2.new(0, 10, 0, math.floor(45 * guiScale))
ScriptNameLabel.BackgroundTransparency = 1
ScriptNameLabel.Text = "Script: Unknown"
ScriptNameLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
ScriptNameLabel.TextSize = math.floor(11 * guiScale)
ScriptNameLabel.Font = Enum.Font.Gotham
ScriptNameLabel.TextXAlignment = Enum.TextXAlignment.Left
ScriptNameLabel.ZIndex = 51
ScriptNameLabel.Parent = EditorFrame

-- Code Editor TextBox
local EditorScrollFrame = Instance.new("ScrollingFrame")
EditorScrollFrame.Size = UDim2.new(1, -20, 1, -math.floor(130 * guiScale))
EditorScrollFrame.Position = UDim2.new(0, 10, 0, math.floor(75 * guiScale))
EditorScrollFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 22)
EditorScrollFrame.BorderSizePixel = 0
EditorScrollFrame.ScrollBarThickness = 4
EditorScrollFrame.ZIndex = 51
EditorScrollFrame.Parent = EditorFrame

local EditorScrollCorner = Instance.new("UICorner")
EditorScrollCorner.CornerRadius = UDim.new(0, 8)
EditorScrollCorner.Parent = EditorScrollFrame

local CodeTextBox = Instance.new("TextBox")
CodeTextBox.Size = UDim2.new(1, -10, 1, 0)
CodeTextBox.Position = UDim2.new(0, 5, 0, 0)
CodeTextBox.BackgroundTransparency = 1
CodeTextBox.Text = ""
CodeTextBox.PlaceholderText = "-- Enter your script here..."
CodeTextBox.TextColor3 = Color3.fromRGB(200, 200, 220)
CodeTextBox.PlaceholderColor3 = Color3.fromRGB(100, 100, 120)
CodeTextBox.TextSize = math.floor(10 * guiScale)
CodeTextBox.Font = Enum.Font.Code
CodeTextBox.TextXAlignment = Enum.TextXAlignment.Left
CodeTextBox.TextYAlignment = Enum.TextYAlignment.Top
CodeTextBox.MultiLine = true
CodeTextBox.ClearTextOnFocus = false
CodeTextBox.TextWrapped = true
CodeTextBox.ZIndex = 52
CodeTextBox.Parent = EditorScrollFrame

-- Auto-resize canvas
CodeTextBox:GetPropertyChangedSignal("TextBounds"):Connect(function()
    EditorScrollFrame.CanvasSize = UDim2.new(0, 0, 0, CodeTextBox.TextBounds.Y + 20)
end)

-- Editor Action Buttons
local EditorBtnFrame = Instance.new("Frame")
EditorBtnFrame.Size = UDim2.new(1, -20, 0, math.floor(40 * guiScale))
EditorBtnFrame.Position = UDim2.new(0, 10, 1, -math.floor(50 * guiScale))
EditorBtnFrame.BackgroundTransparency = 1
EditorBtnFrame.ZIndex = 51
EditorBtnFrame.Parent = EditorFrame

local EditorBtnLayout = Instance.new("UIListLayout")
EditorBtnLayout.FillDirection = Enum.FillDirection.Horizontal
EditorBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
EditorBtnLayout.Padding = UDim.new(0, 10)
EditorBtnLayout.Parent = EditorBtnFrame

-- Run Edited Script Button
local RunEditedBtn = Instance.new("TextButton")
RunEditedBtn.Size = UDim2.new(0, math.floor(100 * guiScale), 0, math.floor(35 * guiScale))
RunEditedBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 60)
RunEditedBtn.Text = "â–¶ï¸ RUN"
RunEditedBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
RunEditedBtn.TextSize = math.floor(12 * guiScale)
RunEditedBtn.Font = Enum.Font.GothamBold
RunEditedBtn.ZIndex = 52
RunEditedBtn.Parent = EditorBtnFrame

local RunEditedCorner = Instance.new("UICorner")
RunEditedCorner.CornerRadius = UDim.new(0, 6)
RunEditedCorner.Parent = RunEditedBtn

-- Copy Edited Script Button
local CopyEditedBtn = Instance.new("TextButton")
CopyEditedBtn.Size = UDim2.new(0, math.floor(100 * guiScale), 0, math.floor(35 * guiScale))
CopyEditedBtn.BackgroundColor3 = Color3.fromRGB(80, 120, 200)
CopyEditedBtn.Text = "ğŸ“‹ COPY"
CopyEditedBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
CopyEditedBtn.TextSize = math.floor(12 * guiScale)
CopyEditedBtn.Font = Enum.Font.GothamBold
CopyEditedBtn.ZIndex = 52
CopyEditedBtn.Parent = EditorBtnFrame

local CopyEditedCorner = Instance.new("UICorner")
CopyEditedCorner.CornerRadius = UDim.new(0, 6)
CopyEditedCorner.Parent = CopyEditedBtn

-- Reset Button
local ResetEditedBtn = Instance.new("TextButton")
ResetEditedBtn.Size = UDim2.new(0, math.floor(100 * guiScale), 0, math.floor(35 * guiScale))
ResetEditedBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 60)
ResetEditedBtn.Text = "ğŸ”„ RESET"
ResetEditedBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
ResetEditedBtn.TextSize = math.floor(12 * guiScale)
ResetEditedBtn.Font = Enum.Font.GothamBold
ResetEditedBtn.ZIndex = 52
ResetEditedBtn.Parent = EditorBtnFrame

local ResetEditedCorner = Instance.new("UICorner")
ResetEditedCorner.CornerRadius = UDim.new(0, 6)
ResetEditedCorner.Parent = ResetEditedBtn

-- Editor state
local currentEditingExploit = nil
local originalCode = ""

-- Editor functions
function GUI_OpenScriptEditor(exploit)
    currentEditingExploit = exploit
    originalCode = exploit.Code or ""
    ScriptNameLabel.Text = "Script: " .. exploit.Name
    CodeTextBox.Text = exploit.Code or "-- No code available"
    EditorFrame.Visible = true
end

local function CloseEditor()
    EditorFrame.Visible = false
    currentEditingExploit = nil
end

EditorCloseBtn.MouseButton1Click:Connect(CloseEditor)

RunEditedBtn.MouseButton1Click:Connect(function()
    if CodeTextBox.Text ~= "" then
        Analyzer:Notify("â–¶ï¸ Execute", "Running edited script...")
        spawn(function()
            local success, err = pcall(function()
                loadstring(CodeTextBox.Text)()
            end)
            if success then
                Analyzer:Notify("âœ… Success", "Edited script is running!")
            else
                Analyzer:Notify("âŒ Error", "Check console for details")
                print("Error:", err)
            end
        end)
    end
end)

CopyEditedBtn.MouseButton1Click:Connect(function()
    if CodeTextBox.Text ~= "" then
        setclipboard(CodeTextBox.Text)
        Analyzer:Notify("ğŸ“‹ Copied", "Edited script copied to clipboard!")
    end
end)

ResetEditedBtn.MouseButton1Click:Connect(function()
    CodeTextBox.Text = originalCode
    Analyzer:Notify("ğŸ”„ Reset", "Script restored to original")
end)

-- Top Bar
local TopBar = Instance.new("Frame")
TopBar.Name = "TopBar"
TopBar.Size = UDim2.new(1, 0, 0, math.floor(55 * guiScale))
TopBar.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
TopBar.BorderSizePixel = 0
TopBar.ZIndex = 2
TopBar.Parent = MainFrame

local TopCorner = Instance.new("UICorner")
TopCorner.CornerRadius = UDim.new(0, 16)
TopCorner.Parent = TopBar

local TopBarFix = Instance.new("Frame")
TopBarFix.Size = UDim2.new(1, 0, 0, 16)
TopBarFix.Position = UDim2.new(0, 0, 1, -16)
TopBarFix.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
TopBarFix.BorderSizePixel = 0
TopBarFix.ZIndex = 2
TopBarFix.Parent = TopBar

local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, -math.floor(120 * guiScale), 0, math.floor(30 * guiScale))
Title.Position = UDim2.new(0, 15, 0, 8)
Title.BackgroundTransparency = 1
Title.Text = "ğŸ§  GAME ANALYZER"
Title.TextColor3 = Color3.fromRGB(100, 180, 255)
Title.TextSize = math.floor(16 * guiScale)
Title.Font = Enum.Font.GothamBold
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.ZIndex = 3
Title.Parent = TopBar

local Version = Instance.new("TextLabel")
Version.Size = UDim2.new(1, -15, 0, math.floor(15 * guiScale))
Version.Position = UDim2.new(0, 15, 0, math.floor(33 * guiScale))
Version.BackgroundTransparency = 1
Version.Text = "v" .. version .. " | 100% Working"
Version.TextColor3 = Color3.fromRGB(120, 120, 130)
Version.TextSize = math.floor(10 * guiScale)
Version.Font = Enum.Font.Gotham
Version.TextXAlignment = Enum.TextXAlignment.Left
Version.ZIndex = 3
Version.Parent = TopBar

local CloseBtn = Instance.new("TextButton")
CloseBtn.Size = UDim2.new(0, math.floor(45 * guiScale), 0, math.floor(45 * guiScale))
CloseBtn.Position = UDim2.new(1, -math.floor(50 * guiScale), 0, 5)
CloseBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
CloseBtn.Text = "âœ•"
CloseBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseBtn.TextSize = math.floor(20 * guiScale)
CloseBtn.Font = Enum.Font.GothamBold
CloseBtn.ZIndex = 3
CloseBtn.Parent = TopBar

local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 10)
CloseCorner.Parent = CloseBtn

CloseBtn.MouseButton1Click:Connect(function()
    Analyzer:StopAll()
    ScreenGui:Destroy()
    print("ğŸ‘‹ GUI Closed")
end)

local MinBtn = Instance.new("TextButton")
MinBtn.Size = UDim2.new(0, math.floor(45 * guiScale), 0, math.floor(45 * guiScale))
MinBtn.Position = UDim2.new(1, -math.floor(100 * guiScale), 0, 5)
MinBtn.BackgroundColor3 = Color3.fromRGB(80, 120, 180)
MinBtn.Text = "âˆ’"
MinBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
MinBtn.TextSize = math.floor(24 * guiScale)
MinBtn.Font = Enum.Font.GothamBold
MinBtn.ZIndex = 3
MinBtn.Parent = TopBar

local MinCorner = Instance.new("UICorner")
MinCorner.CornerRadius = UDim.new(0, 10)
MinCorner.Parent = MinBtn

local isMinimized = false
MinBtn.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    
    if isMinimized then
        MainFrame:TweenSize(
            UDim2.new(0, math.floor(380 * guiScale), 0, math.floor(55 * guiScale)),
            Enum.EasingDirection.Out,
            Enum.EasingStyle.Quad,
            0.3,
            true
        )
        MinBtn.Text = "+"
    else
        MainFrame:TweenSize(
            UDim2.new(0, math.floor(380 * guiScale), 0, math.floor(650 * guiScale)),
            Enum.EasingDirection.Out,
            Enum.EasingStyle.Quad,
            0.3,
            true
        )
        MinBtn.Text = "âˆ’"
    end
end)

-- Tab System
local TabBar = Instance.new("Frame")
TabBar.Size = UDim2.new(1, -20, 0, math.floor(40 * guiScale))
TabBar.Position = UDim2.new(0, 10, 0, math.floor(60 * guiScale))
TabBar.BackgroundTransparency = 1
TabBar.ZIndex = 2
TabBar.Parent = MainFrame

local TabLayout = Instance.new("UIListLayout")
TabLayout.FillDirection = Enum.FillDirection.Horizontal
TabLayout.Padding = UDim.new(0, 5)
TabLayout.SortOrder = Enum.SortOrder.LayoutOrder
TabLayout.Parent = TabBar

local tabs = {"Dashboard", "ğŸ’¯Local", "ğŸ¤–Auto", "ğŸ§ AI", "ğŸ”Deep", "âš ï¸Remote"}
local tabButtons = {}
local tabContents = {}

local function CreateTab(name, order)
    local tabBtn = Instance.new("TextButton")
    tabBtn.Name = name .. "Tab"
    tabBtn.Size = UDim2.new(0, math.floor(68 * guiScale), 1, 0)
    tabBtn.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    tabBtn.Text = name
    tabBtn.TextColor3 = Color3.fromRGB(150, 150, 150)
    tabBtn.TextSize = math.floor(9 * guiScale)
    tabBtn.Font = Enum.Font.GothamBold
    tabBtn.LayoutOrder = order
    tabBtn.ZIndex = 3
    tabBtn.Parent = TabBar
    
    local tabCorner = Instance.new("UICorner")
    tabCorner.CornerRadius = UDim.new(0, 8)
    tabCorner.Parent = tabBtn
    
    tabButtons[name] = tabBtn
    
    local content = Instance.new("ScrollingFrame")
    content.Name = name .. "Content"
    content.Size = UDim2.new(1, -20, 1, -math.floor(115 * guiScale))
    content.Position = UDim2.new(0, 10, 0, math.floor(105 * guiScale))
    content.BackgroundTransparency = 1
    content.BorderSizePixel = 0
    content.ScrollBarThickness = 6
    content.ScrollBarImageColor3 = Color3.fromRGB(100, 180, 255)
    content.CanvasSize = UDim2.new(0, 0, 0, 0)
    content.Visible = (name == "Dashboard")
    content.ZIndex = 2
    content.Parent = MainFrame
    
    local contentLayout = Instance.new("UIListLayout")
    contentLayout.Padding = UDim.new(0, 8)
    contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
    contentLayout.Parent = content
    
    contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        content.CanvasSize = UDim2.new(0, 0, 0, contentLayout.AbsoluteContentSize.Y + 10)
    end)
    
    tabContents[name] = content
    
    return tabBtn, content
end

for i, tabName in ipairs(tabs) do
    CreateTab(tabName, i)
end

local function SwitchTab(tabName)
    Analyzer.CurrentTab = tabName
    
    for name, btn in pairs(tabButtons) do
        if name == tabName then
            btn.BackgroundColor3 = Color3.fromRGB(60, 120, 220)
            btn.TextColor3 = Color3.fromRGB(255, 255, 255)
        else
            btn.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
            btn.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
    end
    
    for name, content in pairs(tabContents) do
        content.Visible = (name == tabName)
    end
end

for name, btn in pairs(tabButtons) do
    btn.MouseButton1Click:Connect(function()
        SwitchTab(name)
    end)
end

-- Helper Functions
local function CreateSection(parent, title)
    local section = Instance.new("TextLabel")
    section.Size = UDim2.new(1, 0, 0, math.floor(35 * guiScale))
    section.BackgroundTransparency = 1
    section.Text = title
    section.TextColor3 = Color3.fromRGB(100, 180, 255)
    section.TextSize = math.floor(14 * guiScale)
    section.Font = Enum.Font.GothamBold
    section.TextXAlignment = Enum.TextXAlignment.Left
    section.ZIndex = 3
    section.Parent = parent
    return section
end

local function CreateLabel(parent, text, height)
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, height or math.floor(25 * guiScale))
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.fromRGB(200, 200, 200)
    label.TextSize = math.floor(11 * guiScale)
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextWrapped = true
    label.ZIndex = 3
    label.Parent = parent
    return label
end

local function CreateButton(parent, text, color, callback)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 0, math.floor(45 * guiScale))
    button.BackgroundColor3 = color
    button.Text = text
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = math.floor(13 * guiScale)
    button.Font = Enum.Font.GothamBold
    button.ZIndex = 3
    button.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = button
    
    button.MouseButton1Click:Connect(callback)
    
    return button
end

-- Create Exploit Cards
local function CreateLocalExploitCard(parent, exploit)
    -- Determine if can be executed (editable OR injectable)
    local canExecute = exploit.IsEditable or CanExecuteValue(exploit)
    local needsNumericInput = exploit.IsEditable and exploit.IsNumeric
    local needsTextInput = exploit.IsEditable and exploit.ValueType == "StringValue"
    local needsBoolInput = exploit.IsEditable and exploit.ValueType == "BoolValue"
    
    -- Calculate height based on inputs needed
    local baseHeight = 95
    if needsNumericInput or needsTextInput then
        baseHeight = 135
    elseif needsBoolInput then
        baseHeight = 120
    end
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, math.floor(baseHeight * guiScale))
    frame.BackgroundColor3 = exploit.IsEditable and Color3.fromRGB(30, 40, 30) or Color3.fromRGB(40, 35, 35)
    frame.BorderSizePixel = 0
    frame.ZIndex = 3
    frame.Parent = parent
    
    local frameCorner = Instance.new("UICorner")
    frameCorner.CornerRadius = UDim.new(0, 8)
    frameCorner.Parent = frame
    
    -- Color-coded border
    local border = Instance.new("UIStroke")
    if exploit.IsEditable then
        border.Color = Color3.fromRGB(60, 180, 60) -- Green = Editable
    elseif canExecute then
        border.Color = Color3.fromRGB(255, 180, 60) -- Orange = Injectable
    else
        border.Color = Color3.fromRGB(180, 60, 60) -- Red = Read-only
    end
    border.Thickness = 2
    border.Parent = frame
    
    local icon = Instance.new("TextLabel")
    icon.Size = UDim2.new(0, math.floor(35 * guiScale), 0, math.floor(35 * guiScale))
    icon.Position = UDim2.new(0, 5, 0, 5)
    icon.BackgroundColor3 = exploit.IsEditable and Color3.fromRGB(40, 50, 40) or Color3.fromRGB(50, 40, 40)
    icon.Text = exploit.Icon
    icon.TextSize = math.floor(18 * guiScale)
    icon.ZIndex = 4
    icon.Parent = frame
    
    local iconCorner = Instance.new("UICorner")
    iconCorner.CornerRadius = UDim.new(0, 6)
    iconCorner.Parent = icon
    
    local name = Instance.new("TextLabel")
    name.Size = UDim2.new(1, -math.floor(50 * guiScale), 0, math.floor(18 * guiScale))
    name.Position = UDim2.new(0, math.floor(45 * guiScale), 0, 5)
    name.BackgroundTransparency = 1
    name.Text = exploit.Name
    name.TextColor3 = exploit.IsEditable and Color3.fromRGB(60, 255, 60) or 
                      (canExecute and Color3.fromRGB(255, 200, 100) or Color3.fromRGB(255, 100, 100))
    name.TextSize = math.floor(12 * guiScale)
    name.Font = Enum.Font.GothamBold
    name.TextXAlignment = Enum.TextXAlignment.Left
    name.TextTruncate = Enum.TextTruncate.AtEnd
    name.ZIndex = 4
    name.Parent = frame
    
    local desc = Instance.new("TextLabel")
    desc.Size = UDim2.new(1, -math.floor(50 * guiScale), 0, math.floor(30 * guiScale))
    desc.Position = UDim2.new(0, math.floor(45 * guiScale), 0, 23)
    desc.BackgroundTransparency = 1
    desc.Text = exploit.Description
    desc.TextColor3 = Color3.fromRGB(180, 180, 180)
    desc.TextSize = math.floor(10 * guiScale)
    desc.Font = Enum.Font.Gotham
    desc.TextXAlignment = Enum.TextXAlignment.Left
    desc.TextWrapped = true
    desc.TextYAlignment = Enum.TextYAlignment.Top
    desc.ZIndex = 4
    desc.Parent = frame
    
    local action = Instance.new("TextLabel")
    action.Size = UDim2.new(1, -10, 0, math.floor(25 * guiScale))
    action.Position = UDim2.new(0, 5, 0, math.floor(55 * guiScale))
    action.BackgroundTransparency = 1
    action.Text = "ğŸ’¡ " .. exploit.Action
    action.TextColor3 = exploit.IsEditable and Color3.fromRGB(100, 200, 255) or 
                       (canExecute and Color3.fromRGB(255, 180, 100) or Color3.fromRGB(200, 100, 100))
    action.TextSize = math.floor(9 * guiScale)
    action.Font = Enum.Font.GothamMedium
    action.TextXAlignment = Enum.TextXAlignment.Left
    action.TextWrapped = true
    action.TextYAlignment = Enum.TextYAlignment.Top
    action.ZIndex = 4
    action.Parent = frame
    
    local reliability = Instance.new("TextLabel")
    reliability.Size = UDim2.new(0, math.floor(100 * guiScale), 0, math.floor(15 * guiScale))
    reliability.Position = UDim2.new(1, -math.floor(105 * guiScale), 0, math.floor(5 * guiScale))
    reliability.BackgroundColor3 = exploit.IsEditable and Color3.fromRGB(60, 180, 60) or
                                   (canExecute and Color3.fromRGB(255, 140, 60) or Color3.fromRGB(180, 60, 60))
    reliability.Text = exploit.IsEditable and "âœ… EDITABLE" or
                       (canExecute and "âš ï¸ INJECT" or "âŒ READ-ONLY")
    reliability.TextColor3 = Color3.fromRGB(255, 255, 255)
    reliability.TextSize = math.floor(8 * guiScale)
    reliability.Font = Enum.Font.GothamBold
    reliability.ZIndex = 4
    reliability.Parent = frame
    
    local reliabilityCorner = Instance.new("UICorner")
    reliabilityCorner.CornerRadius = UDim.new(0, 4)
    reliabilityCorner.Parent = reliability
    
    -- NUMERIC INPUT (for numbers only)
    if needsNumericInput then
        local editorLabel = Instance.new("TextLabel")
        editorLabel.Size = UDim2.new(0, math.floor(80 * guiScale), 0, math.floor(15 * guiScale))
        editorLabel.Position = UDim2.new(0, 5, 0, math.floor(85 * guiScale))
        editorLabel.BackgroundTransparency = 1
        editorLabel.Text = "New Value:"
        editorLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        editorLabel.TextSize = math.floor(10 * guiScale)
        editorLabel.Font = Enum.Font.Gotham
        editorLabel.TextXAlignment = Enum.TextXAlignment.Left
        editorLabel.ZIndex = 4
        editorLabel.Parent = frame
        
        local valueInput = Instance.new("TextBox")
        valueInput.Size = UDim2.new(0, math.floor(180 * guiScale), 0, math.floor(30 * guiScale))
        valueInput.Position = UDim2.new(0, 5, 0, math.floor(100 * guiScale))
        valueInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        valueInput.Text = tostring(exploit.CurrentValue)
        valueInput.PlaceholderText = "Enter number (e.g. 999999)"
        valueInput.TextColor3 = Color3.fromRGB(255, 255, 255)
        valueInput.TextSize = math.floor(11 * guiScale)
        valueInput.Font = Enum.Font.Gotham
        valueInput.ClearTextOnFocus = false
        valueInput.ZIndex = 4
        valueInput.Parent = frame
        
        local inputCorner = Instance.new("UICorner")
        inputCorner.CornerRadius = UDim.new(0, 6)
        inputCorner.Parent = valueInput
        
        local executeBtn = Instance.new("TextButton")
        executeBtn.Size = UDim2.new(0, math.floor(165 * guiScale), 0, math.floor(30 * guiScale))
        executeBtn.Position = UDim2.new(0, math.floor(190 * guiScale), 0, math.floor(100 * guiScale))
        executeBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 60)
        executeBtn.Text = "âœ… APPLY VALUE"
        executeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        executeBtn.TextSize = math.floor(11 * guiScale)
        executeBtn.Font = Enum.Font.GothamBold
        executeBtn.ZIndex = 4
        executeBtn.Parent = frame
        
        local execCorner = Instance.new("UICorner")
        execCorner.CornerRadius = UDim.new(0, 6)
        execCorner.Parent = executeBtn
        
        executeBtn.MouseButton1Click:Connect(function()
            local newVal = tonumber(valueInput.Text)
            if newVal then
                local success = Analyzer:ExecuteValue(exploit, newVal)
                if success then
                    valueInput.Text = tostring(newVal)
                end
            else
                Analyzer:Notify("âŒ Error", "Please enter a valid number")
            end
        end)
    
    -- TEXT INPUT (for strings)
    elseif needsTextInput then
        local editorLabel = Instance.new("TextLabel")
        editorLabel.Size = UDim2.new(0, math.floor(80 * guiScale), 0, math.floor(15 * guiScale))
        editorLabel.Position = UDim2.new(0, 5, 0, math.floor(85 * guiScale))
        editorLabel.BackgroundTransparency = 1
        editorLabel.Text = "New Text:"
        editorLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        editorLabel.TextSize = math.floor(10 * guiScale)
        editorLabel.Font = Enum.Font.Gotham
        editorLabel.TextXAlignment = Enum.TextXAlignment.Left
        editorLabel.ZIndex = 4
        editorLabel.Parent = frame
        
        local valueInput = Instance.new("TextBox")
        valueInput.Size = UDim2.new(0, math.floor(180 * guiScale), 0, math.floor(30 * guiScale))
        valueInput.Position = UDim2.new(0, 5, 0, math.floor(100 * guiScale))
        valueInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        valueInput.Text = tostring(exploit.CurrentValue)
        valueInput.PlaceholderText = "Enter text..."
        valueInput.TextColor3 = Color3.fromRGB(255, 255, 255)
        valueInput.TextSize = math.floor(11 * guiScale)
        valueInput.Font = Enum.Font.Gotham
        valueInput.ClearTextOnFocus = false
        valueInput.ZIndex = 4
        valueInput.Parent = frame
        
        local inputCorner = Instance.new("UICorner")
        inputCorner.CornerRadius = UDim.new(0, 6)
        inputCorner.Parent = valueInput
        
        local executeBtn = Instance.new("TextButton")
        executeBtn.Size = UDim2.new(0, math.floor(165 * guiScale), 0, math.floor(30 * guiScale))
        executeBtn.Position = UDim2.new(0, math.floor(190 * guiScale), 0, math.floor(100 * guiScale))
        executeBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 60)
        executeBtn.Text = "âœ… APPLY TEXT"
        executeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        executeBtn.TextSize = math.floor(11 * guiScale)
        executeBtn.Font = Enum.Font.GothamBold
        executeBtn.ZIndex = 4
        executeBtn.Parent = frame
        
        local execCorner = Instance.new("UICorner")
        execCorner.CornerRadius = UDim.new(0, 6)
        execCorner.Parent = executeBtn
        
        executeBtn.MouseButton1Click:Connect(function()
            Analyzer:ExecuteValue(exploit, valueInput.Text)
        end)
    
    -- BOOL TOGGLE (for booleans)
    elseif needsBoolInput then
        local toggleFrame = Instance.new("Frame")
        toggleFrame.Size = UDim2.new(0, math.floor(340 * guiScale), 0, math.floor(35 * guiScale))
        toggleFrame.Position = UDim2.new(0, 10, 0, math.floor(80 * guiScale))
        toggleFrame.BackgroundTransparency = 1
        toggleFrame.ZIndex = 4
        toggleFrame.Parent = frame
        
        local trueBtn = Instance.new("TextButton")
        trueBtn.Size = UDim2.new(0, math.floor(160 * guiScale), 1, 0)
        trueBtn.Position = UDim2.new(0, 0, 0, 0)
        trueBtn.BackgroundColor3 = exploit.CurrentValue == true and Color3.fromRGB(60, 180, 60) or Color3.fromRGB(60, 60, 70)
        trueBtn.Text = "âœ… TRUE"
        trueBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        trueBtn.TextSize = math.floor(11 * guiScale)
        trueBtn.Font = Enum.Font.GothamBold
        trueBtn.ZIndex = 5
        trueBtn.Parent = toggleFrame
        
        local trueCorner = Instance.new("UICorner")
        trueCorner.CornerRadius = UDim.new(0, 6)
        trueCorner.Parent = trueBtn
        
        local falseBtn = Instance.new("TextButton")
        falseBtn.Size = UDim2.new(0, math.floor(160 * guiScale), 1, 0)
        falseBtn.Position = UDim2.new(0, math.floor(170 * guiScale), 0, 0)
        falseBtn.BackgroundColor3 = exploit.CurrentValue == false and Color3.fromRGB(180, 60, 60) or Color3.fromRGB(60, 60, 70)
        falseBtn.Text = "âŒ FALSE"
        falseBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        falseBtn.TextSize = math.floor(11 * guiScale)
        falseBtn.Font = Enum.Font.GothamBold
        falseBtn.ZIndex = 5
        falseBtn.Parent = toggleFrame
        
        local falseCorner = Instance.new("UICorner")
        falseCorner.CornerRadius = UDim.new(0, 6)
        falseCorner.Parent = falseBtn
        
        trueBtn.MouseButton1Click:Connect(function()
            Analyzer:ExecuteValue(exploit, true)
            trueBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 60)
            falseBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
        end)
        
        falseBtn.MouseButton1Click:Connect(function()
            Analyzer:ExecuteValue(exploit, false)
            trueBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
            falseBtn.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
        end)
    
    -- NO INPUT - Just info or inject button
    else
        local btnWidth = canExecute and math.floor(165 * guiScale) or math.floor(165 * guiScale)
        local actionBtn = Instance.new("TextButton")
        actionBtn.Size = UDim2.new(0, btnWidth, 0, math.floor(30 * guiScale))
        actionBtn.Position = UDim2.new(1, -btnWidth - 5, 1, -35)
        actionBtn.BackgroundColor3 = canExecute and Color3.fromRGB(255, 140, 60) or Color3.fromRGB(100, 100, 120)
        actionBtn.Text = canExecute and "âš¡ TRY INJECT" or "â„¹ï¸ VIEW INFO"
        actionBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        actionBtn.TextSize = math.floor(11 * guiScale)
        actionBtn.Font = Enum.Font.GothamBold
        actionBtn.ZIndex = 4
        actionBtn.Parent = frame
        
        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 6)
        btnCorner.Parent = actionBtn
        
        actionBtn.MouseButton1Click:Connect(function()
            if canExecute then
                -- Try to inject/trigger the value
                Analyzer:ExecuteValue(exploit, exploit.CurrentValue)
            else
                -- Just show info
                Analyzer:Notify("â„¹ï¸ Info", string.format("%s\nCurrent: %s\nType: %s\nPath: %s", 
                    exploit.Name, 
                    tostring(exploit.CurrentValue),
                    exploit.ValueType,
                    exploit.Path))
            end
        end)
    end
    
    return frame
end

local function CreateAutoExploitCard(parent, exploit)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, math.floor(140 * guiScale))  -- Increased height for new buttons
    frame.BackgroundColor3 = Color3.fromRGB(30, 35, 40)
    frame.BorderSizePixel = 0
    frame.ZIndex = 3
    frame.Parent = parent
    
    local frameCorner = Instance.new("UICorner")
    frameCorner.CornerRadius = UDim.new(0, 8)
    frameCorner.Parent = frame
    
    local border = Instance.new("UIStroke")
    border.Color = Color3.fromRGB(100, 150, 255)
    border.Thickness = 2
    border.Parent = frame
    
    local icon = Instance.new("TextLabel")
    icon.Size = UDim2.new(0, math.floor(35 * guiScale), 0, math.floor(35 * guiScale))
    icon.Position = UDim2.new(0, 5, 0, 5)
    icon.BackgroundColor3 = Color3.fromRGB(40, 45, 50)
    icon.Text = exploit.Icon
    icon.TextSize = math.floor(18 * guiScale)
    icon.ZIndex = 4
    icon.Parent = frame
    
    local iconCorner = Instance.new("UICorner")
    iconCorner.CornerRadius = UDim.new(0, 6)
    iconCorner.Parent = icon
    
    local name = Instance.new("TextLabel")
    name.Size = UDim2.new(1, -math.floor(150 * guiScale), 0, math.floor(18 * guiScale))
    name.Position = UDim2.new(0, math.floor(45 * guiScale), 0, 5)
    name.BackgroundTransparency = 1
    name.Text = exploit.Name
    name.TextColor3 = Color3.fromRGB(100, 200, 255)
    name.TextSize = math.floor(12 * guiScale)
    name.Font = Enum.Font.GothamBold
    name.TextXAlignment = Enum.TextXAlignment.Left
    name.TextTruncate = Enum.TextTruncate.AtEnd
    name.ZIndex = 4
    name.Parent = frame
    
    local desc = Instance.new("TextLabel")
    desc.Size = UDim2.new(1, -math.floor(150 * guiScale), 0, math.floor(30 * guiScale))
    desc.Position = UDim2.new(0, math.floor(45 * guiScale), 0, 23)
    desc.BackgroundTransparency = 1
    desc.Text = exploit.Description
    desc.TextColor3 = Color3.fromRGB(180, 180, 180)
    desc.TextSize = math.floor(10 * guiScale)
    desc.Font = Enum.Font.Gotham
    desc.TextXAlignment = Enum.TextXAlignment.Left
    desc.TextWrapped = true
    desc.TextYAlignment = Enum.TextYAlignment.Top
    desc.ZIndex = 4
    desc.Parent = frame
    
    local action = Instance.new("TextLabel")
    action.Size = UDim2.new(1, -math.floor(150 * guiScale), 0, math.floor(25 * guiScale))
    action.Position = UDim2.new(0, math.floor(45 * guiScale), 0, 55)
    action.BackgroundTransparency = 1
    action.Text = "ğŸ’¡ " .. exploit.Action
    action.TextColor3 = Color3.fromRGB(100, 200, 255)
    action.TextSize = math.floor(9 * guiScale)
    action.Font = Enum.Font.GothamMedium
    action.TextXAlignment = Enum.TextXAlignment.Left
    action.TextWrapped = true
    action.TextYAlignment = Enum.TextYAlignment.Top
    action.ZIndex = 4
    action.Parent = frame
    
    -- START LOOP Button
    local startBtn = Instance.new("TextButton")
    startBtn.Size = UDim2.new(0, math.floor(130 * guiScale), 0, math.floor(35 * guiScale))
    startBtn.Position = UDim2.new(1, -math.floor(135 * guiScale), 0, 10)
    startBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 60)
    startBtn.Text = "â–¶ï¸ START LOOP"
    startBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    startBtn.TextSize = math.floor(11 * guiScale)
    startBtn.Font = Enum.Font.GothamBold
    startBtn.ZIndex = 4
    startBtn.Parent = frame
    
    local startCorner = Instance.new("UICorner")
    startCorner.CornerRadius = UDim.new(0, 6)
    startCorner.Parent = startBtn
    
    -- STOP Button
    local stopBtn = Instance.new("TextButton")
    stopBtn.Size = UDim2.new(0, math.floor(130 * guiScale), 0, math.floor(35 * guiScale))
    stopBtn.Position = UDim2.new(1, -math.floor(135 * guiScale), 0, 50)
    stopBtn.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
    stopBtn.Text = "â¹ï¸ STOP"
    stopBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    stopBtn.TextSize = math.floor(11 * guiScale)
    stopBtn.Font = Enum.Font.GothamBold
    stopBtn.ZIndex = 4
    stopBtn.Parent = frame
    
    local stopCorner = Instance.new("UICorner")
    stopCorner.CornerRadius = UDim.new(0, 6)
    stopCorner.Parent = stopBtn
    
    -- Bottom button row for COPY and EDIT
    local bottomBtnFrame = Instance.new("Frame")
    bottomBtnFrame.Size = UDim2.new(1, -10, 0, math.floor(35 * guiScale))
    bottomBtnFrame.Position = UDim2.new(0, 5, 1, -math.floor(40 * guiScale))
    bottomBtnFrame.BackgroundTransparency = 1
    bottomBtnFrame.ZIndex = 4
    bottomBtnFrame.Parent = frame
    
    -- COPY SCRIPT Button
    local copyBtn = Instance.new("TextButton")
    copyBtn.Size = UDim2.new(0, math.floor(165 * guiScale), 1, 0)
    copyBtn.Position = UDim2.new(0, 0, 0, 0)
    copyBtn.BackgroundColor3 = Color3.fromRGB(80, 120, 200)
    copyBtn.Text = "ğŸ“‹ COPY SCRIPT"
    copyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    copyBtn.TextSize = math.floor(11 * guiScale)
    copyBtn.Font = Enum.Font.GothamBold
    copyBtn.ZIndex = 5
    copyBtn.Parent = bottomBtnFrame
    
    local copyCorner = Instance.new("UICorner")
    copyCorner.CornerRadius = UDim.new(0, 6)
    copyCorner.Parent = copyBtn
    
    -- EDIT SCRIPT Button
    local editBtn = Instance.new("TextButton")
    editBtn.Size = UDim2.new(0, math.floor(165 * guiScale), 1, 0)
    editBtn.Position = UDim2.new(0, math.floor(175 * guiScale), 0, 0)
    editBtn.BackgroundColor3 = Color3.fromRGB(200, 140, 60)
    editBtn.Text = "âœï¸ EDIT SCRIPT"
    editBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    editBtn.TextSize = math.floor(11 * guiScale)
    editBtn.Font = Enum.Font.GothamBold
    editBtn.ZIndex = 5
    editBtn.Parent = bottomBtnFrame
    
    local editCorner = Instance.new("UICorner")
    editCorner.CornerRadius = UDim.new(0, 6)
    editCorner.Parent = editBtn
    
    -- Button connections
    startBtn.MouseButton1Click:Connect(function()
        if exploit.Type == "ClickDetector" then
            Analyzer:ExecuteAutoClick(exploit)
        elseif exploit.Type == "ProximityPrompt" then
            Analyzer:ExecuteProximityPrompt(exploit)
        end
    end)
    
    stopBtn.MouseButton1Click:Connect(function()
        Analyzer.ActiveLoops[exploit.Path] = false
    end)
    
    copyBtn.MouseButton1Click:Connect(function()
        if exploit.Code then
            setclipboard(exploit.Code)
            Analyzer:Notify("ğŸ“‹ Copied", exploit.Name .. " script copied to clipboard!")
        else
            Analyzer:Notify("âŒ Error", "No script code available")
        end
    end)
    
    editBtn.MouseButton1Click:Connect(function()
        if exploit.Code then
            -- Open script editor popup
            GUI_OpenScriptEditor(exploit)
        else
            Analyzer:Notify("âŒ Error", "No script code available to edit")
        end
    end)
    
    return frame
end

local function CreateAIScriptCard(parent, script)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, math.floor(110 * guiScale))
    frame.BackgroundColor3 = Color3.fromRGB(35, 25, 45)
    frame.BorderSizePixel = 0
    frame.ZIndex = 3
    frame.Parent = parent
    
    local frameCorner = Instance.new("UICorner")
    frameCorner.CornerRadius = UDim.new(0, 8)
    frameCorner.Parent = frame
    
    -- Purple/Blue gradient border for AI
    local border = Instance.new("UIStroke")
    border.Color = Color3.fromRGB(138, 43, 226) -- Purple
    border.Thickness = 3
    border.Parent = frame
    
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 0, 130))
    }
    gradient.Rotation = 45
    gradient.Parent = border
    
    local icon = Instance.new("TextLabel")
    icon.Size = UDim2.new(0, math.floor(40 * guiScale), 0, math.floor(40 * guiScale))
    icon.Position = UDim2.new(0, 5, 0, 5)
    icon.BackgroundColor3 = Color3.fromRGB(50, 30, 70)
    icon.Text = "ğŸ§ "
    icon.TextSize = math.floor(20 * guiScale)
    icon.ZIndex = 4
    icon.Parent = frame
    
    local iconCorner = Instance.new("UICorner")
    iconCorner.CornerRadius = UDim.new(0, 8)
    iconCorner.Parent = icon
    
    local name = Instance.new("TextLabel")
    name.Size = UDim2.new(1, -math.floor(55 * guiScale), 0, math.floor(20 * guiScale))
    name.Position = UDim2.new(0, math.floor(50 * guiScale), 0, 5)
    name.BackgroundTransparency = 1
    name.Text = script.Name
    name.TextColor3 = Color3.fromRGB(200, 150, 255)
    name.TextSize = math.floor(13 * guiScale)
    name.Font = Enum.Font.GothamBold
    name.TextXAlignment = Enum.TextXAlignment.Left
    name.TextTruncate = Enum.TextTruncate.AtEnd
    name.ZIndex = 4
    name.Parent = frame
    
    local type = Instance.new("TextLabel")
    type.Size = UDim2.new(0, math.floor(120 * guiScale), 0, math.floor(15 * guiScale))
    type.Position = UDim2.new(1, -math.floor(125 * guiScale), 0, 7)
    type.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    type.Text = "ğŸ¤– AI GENERATED"
    type.TextColor3 = Color3.fromRGB(255, 255, 255)
    type.TextSize = math.floor(8 * guiScale)
    type.Font = Enum.Font.GothamBold
    type.ZIndex = 4
    type.Parent = frame
    
    local typeCorner = Instance.new("UICorner")
    typeCorner.CornerRadius = UDim.new(0, 4)
    typeCorner.Parent = type
    
    local desc = Instance.new("TextLabel")
    desc.Size = UDim2.new(1, -math.floor(55 * guiScale), 0, math.floor(35 * guiScale))
    desc.Position = UDim2.new(0, math.floor(50 * guiScale), 0, 27)
    desc.BackgroundTransparency = 1
    desc.Text = script.Description
    desc.TextColor3 = Color3.fromRGB(180, 180, 200)
    desc.TextSize = math.floor(10 * guiScale)
    desc.Font = Enum.Font.Gotham
    desc.TextXAlignment = Enum.TextXAlignment.Left
    desc.TextWrapped = true
    desc.TextYAlignment = Enum.TextYAlignment.Top
    desc.ZIndex = 4
    desc.Parent = frame
    
    local category = Instance.new("TextLabel")
    category.Size = UDim2.new(1, -math.floor(55 * guiScale), 0, math.floor(15 * guiScale))
    category.Position = UDim2.new(0, math.floor(50 * guiScale), 0, 62)
    category.BackgroundTransparency = 1
    category.Text = "ğŸ“‚ " .. script.Category
    category.TextColor3 = Color3.fromRGB(150, 120, 200)
    category.TextSize = math.floor(9 * guiScale)
    category.Font = Enum.Font.Gotham
    category.TextXAlignment = Enum.TextXAlignment.Left
    category.ZIndex = 4
    category.Parent = frame
    
    -- Run Button
    local runBtn = Instance.new("TextButton")
    runBtn.Size = UDim2.new(0, math.floor(110 * guiScale), 0, math.floor(30 * guiScale))
    runBtn.Position = UDim2.new(0, 5, 1, -35)
    runBtn.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    runBtn.Text = "ğŸš€ RUN BOT"
    runBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    runBtn.TextSize = math.floor(11 * guiScale)
    runBtn.Font = Enum.Font.GothamBold
    runBtn.ZIndex = 4
    runBtn.Parent = frame
    
    local runCorner = Instance.new("UICorner")
    runCorner.CornerRadius = UDim.new(0, 6)
    runCorner.Parent = runBtn
    
    runBtn.MouseButton1Click:Connect(function()
        Analyzer:Notify("ğŸ§  AI Bot", "Starting " .. script.Name)
        spawn(function()
            local success, err = pcall(function()
                loadstring(script.Code)()
            end)
            if success then
                Analyzer:Notify("âœ… Success", script.Name .. " is running!")
            else
                Analyzer:Notify("âŒ Error", "Check console for details")
                print("Error:", err)
            end
        end)
    end)
    
    -- Copy Button
    local copyBtn = Instance.new("TextButton")
    copyBtn.Size = UDim2.new(0, math.floor(120 * guiScale), 0, math.floor(30 * guiScale))
    copyBtn.Position = UDim2.new(0, math.floor(120 * guiScale), 1, -35)
    copyBtn.BackgroundColor3 = Color3.fromRGB(80, 120, 200)
    copyBtn.Text = "ğŸ“‹ COPY SCRIPT"
    copyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    copyBtn.TextSize = math.floor(11 * guiScale)
    copyBtn.Font = Enum.Font.GothamBold
    copyBtn.ZIndex = 4
    copyBtn.Parent = frame
    
    local copyCorner = Instance.new("UICorner")
    copyCorner.CornerRadius = UDim.new(0, 6)
    copyCorner.Parent = copyBtn
    
    copyBtn.MouseButton1Click:Connect(function()
        setclipboard(script.Code)
        Analyzer:Notify("ğŸ“‹ Copied", script.Name .. " copied to clipboard!")
    end)
    
    -- Info Button
    local infoBtn = Instance.new("TextButton")
    infoBtn.Size = UDim2.new(0, math.floor(110 * guiScale), 0, math.floor(30 * guiScale))
    infoBtn.Position = UDim2.new(1, -math.floor(115 * guiScale), 1, -35)
    infoBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 120)
    infoBtn.Text = "â„¹ï¸ INFO"
    infoBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    infoBtn.TextSize = math.floor(11 * guiScale)
    infoBtn.Font = Enum.Font.GothamBold
    infoBtn.ZIndex = 4
    infoBtn.Parent = frame
    
    local infoCorner = Instance.new("UICorner")
    infoCorner.CornerRadius = UDim.new(0, 6)
    infoCorner.Parent = infoBtn
    
    infoBtn.MouseButton1Click:Connect(function()
        Analyzer:Notify("â„¹ï¸ " .. script.Name, script.Description)
    end)
    
    return frame
end

local function CreateRemoteExploitCard(parent, exploit)
    local hasParams = #exploit.Parameters > 0
    local cardHeight = hasParams and math.floor(160 * guiScale) or math.floor(95 * guiScale)
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, cardHeight)
    frame.BackgroundColor3 = Color3.fromRGB(40, 30, 30)
    frame.BorderSizePixel = 0
    frame.ZIndex = 3
    frame.Parent = parent
    
    local frameCorner = Instance.new("UICorner")
    frameCorner.CornerRadius = UDim.new(0, 8)
    frameCorner.Parent = frame
    
    local border = Instance.new("UIStroke")
    border.Color = Color3.fromRGB(200, 100, 60)
    border.Thickness = 2
    border.Parent = frame
    
    local icon = Instance.new("TextLabel")
    icon.Size = UDim2.new(0, math.floor(35 * guiScale), 0, math.floor(35 * guiScale))
    icon.Position = UDim2.new(0, 5, 0, 5)
    icon.BackgroundColor3 = Color3.fromRGB(50, 40, 40)
    icon.Text = exploit.Icon
    icon.TextSize = math.floor(18 * guiScale)
    icon.ZIndex = 4
    icon.Parent = frame
    
    local iconCorner = Instance.new("UICorner")
    iconCorner.CornerRadius = UDim.new(0, 6)
    iconCorner.Parent = icon
    
    local name = Instance.new("TextLabel")
    name.Size = UDim2.new(1, -math.floor(50 * guiScale), 0, math.floor(18 * guiScale))
    name.Position = UDim2.new(0, math.floor(45 * guiScale), 0, 5)
    name.BackgroundTransparency = 1
    name.Text = exploit.Name
    name.TextColor3 = Color3.fromRGB(255, 150, 100)
    name.TextSize = math.floor(12 * guiScale)
    name.Font = Enum.Font.GothamBold
    name.TextXAlignment = Enum.TextXAlignment.Left
    name.TextTruncate = Enum.TextTruncate.AtEnd
    name.ZIndex = 4
    name.Parent = frame
    
    local desc = Instance.new("TextLabel")
    desc.Size = UDim2.new(1, -math.floor(50 * guiScale), 0, math.floor(30 * guiScale))
    desc.Position = UDim2.new(0, math.floor(45 * guiScale), 0, 23)
    desc.BackgroundTransparency = 1
    desc.Text = exploit.Description
    desc.TextColor3 = Color3.fromRGB(180, 180, 180)
    desc.TextSize = math.floor(10 * guiScale)
    desc.Font = Enum.Font.Gotham
    desc.TextXAlignment = Enum.TextXAlignment.Left
    desc.TextWrapped = true
    desc.TextYAlignment = Enum.TextYAlignment.Top
    desc.ZIndex = 4
    desc.Parent = frame
    
    local action = Instance.new("TextLabel")
    action.Size = UDim2.new(1, -10, 0, math.floor(25 * guiScale))
    action.Position = UDim2.new(0, 5, 0, math.floor(55 * guiScale))
    action.BackgroundTransparency = 1
    action.Text = "âš ï¸ " .. exploit.Action
    action.TextColor3 = Color3.fromRGB(255, 180, 100)
    action.TextSize = math.floor(9 * guiScale)
    action.Font = Enum.Font.GothamMedium
    action.TextXAlignment = Enum.TextXAlignment.Left
    action.TextWrapped = true
    action.TextYAlignment = Enum.TextYAlignment.Top
    action.ZIndex = 4
    action.Parent = frame
    
    local reliability = Instance.new("TextLabel")
    reliability.Size = UDim2.new(0, math.floor(100 * guiScale), 0, math.floor(15 * guiScale))
    reliability.Position = UDim2.new(1, -math.floor(105 * guiScale), 0, math.floor(5 * guiScale))
    reliability.BackgroundColor3 = Color3.fromRGB(200, 100, 60)
    reliability.Text = "âš ï¸ ADVANCED"
    reliability.TextColor3 = Color3.fromRGB(255, 255, 255)
    reliability.TextSize = math.floor(8 * guiScale)
    reliability.Font = Enum.Font.GothamBold
    reliability.ZIndex = 4
    reliability.Parent = frame
    
    local reliabilityCorner = Instance.new("UICorner")
    reliabilityCorner.CornerRadius = UDim.new(0, 4)
    reliabilityCorner.Parent = reliability
    
    -- Parameter inputs if available
    local paramInputs = {}
    if hasParams then
        local yPos = 85
        
        for i, param in ipairs(exploit.Parameters) do
            if i > 2 then break end -- Max 2 params to show
            
            local paramLabel = Instance.new("TextLabel")
            paramLabel.Size = UDim2.new(0, math.floor(100 * guiScale), 0, math.floor(15 * guiScale))
            paramLabel.Position = UDim2.new(0, 5, 0, yPos)
            paramLabel.BackgroundTransparency = 1
            paramLabel.Text = param.name .. ":"
            paramLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
            paramLabel.TextSize = math.floor(9 * guiScale)
            paramLabel.Font = Enum.Font.Gotham
            paramLabel.TextXAlignment = Enum.TextXAlignment.Left
            paramLabel.ZIndex = 4
            paramLabel.Parent = frame
            
            local paramInput = Instance.new("TextBox")
            paramInput.Size = UDim2.new(0, math.floor(240 * guiScale), 0, math.floor(25 * guiScale))
            paramInput.Position = UDim2.new(0, math.floor(110 * guiScale), 0, yPos - 5)
            paramInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
            paramInput.Text = tostring(param.default)
            paramInput.PlaceholderText = param.desc
            paramInput.TextColor3 = Color3.fromRGB(255, 255, 255)
            paramInput.TextSize = math.floor(10 * guiScale)
            paramInput.Font = Enum.Font.Gotham
            paramInput.ClearTextOnFocus = false
            paramInput.ZIndex = 4
            paramInput.Parent = frame
            
            local inputCorner = Instance.new("UICorner")
            inputCorner.CornerRadius = UDim.new(0, 4)
            inputCorner.Parent = paramInput
            
            paramInputs[i] = paramInput
            
            yPos = yPos + 30
        end
    end
    
    local testBtn = Instance.new("TextButton")
    testBtn.Size = UDim2.new(0, math.floor(165 * guiScale), 0, math.floor(30 * guiScale))
    testBtn.Position = UDim2.new(0, 5, 1, -35)
    testBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 60)
    testBtn.Text = "ğŸ§ª TEST EXECUTE"
    testBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    testBtn.TextSize = math.floor(11 * guiScale)
    testBtn.Font = Enum.Font.GothamBold
    testBtn.ZIndex = 4
    testBtn.Parent = frame
    
    local testCorner = Instance.new("UICorner")
    testCorner.CornerRadius = UDim.new(0, 6)
    testCorner.Parent = testBtn
    
    testBtn.MouseButton1Click:Connect(function()
        local args = {}
        for i, input in ipairs(paramInputs) do
            local val = input.Text
            if tonumber(val) then
                args[i] = tonumber(val)
            else
                args[i] = val
            end
        end
        Analyzer:ExecuteRemote(exploit, args)
    end)
    
    local copyBtn = Instance.new("TextButton")
    copyBtn.Size = UDim2.new(0, math.floor(165 * guiScale), 0, math.floor(30 * guiScale))
    copyBtn.Position = UDim2.new(0, math.floor(175 * guiScale), 1, -35)
    copyBtn.BackgroundColor3 = Color3.fromRGB(80, 120, 180)
    copyBtn.Text = "ğŸ“‹ COPY PATH"
    copyBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    copyBtn.TextSize = math.floor(11 * guiScale)
    copyBtn.Font = Enum.Font.GothamBold
    copyBtn.ZIndex = 4
    copyBtn.Parent = frame
    
    local copyCorner = Instance.new("UICorner")
    copyCorner.CornerRadius = UDim.new(0, 6)
    copyCorner.Parent = copyBtn
    
    copyBtn.MouseButton1Click:Connect(function()
        setclipboard(exploit.Path)
        Analyzer:Notify("ğŸ“‹ Copied", "Path copied to clipboard")
    end)
    
    return frame
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DEEP SCAN CARD WITH COPY, EDIT & EXECUTE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function GenerateDeepScanScript(item)
    local scriptCode = ""
    
    if item.Type == "Script" or item.Type == "LocalScript" then
        scriptCode = string.format([[
-- ğŸ“œ SCRIPT CONTROL
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("LuaSourceContainer") then
    -- Toggle script disabled state
    current.Disabled = not current.Disabled
    print("âœ… Script " .. (current.Disabled and "DISABLED" or "ENABLED") .. ": %s")
else
    warn("âŒ Script not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name)

    elseif item.Type == "ModuleScript" then
        scriptCode = string.format([[
-- ğŸ“¦ MODULE SCRIPT REQUIRE
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("ModuleScript") then
    local success, result = pcall(function()
        return require(current)
    end)
    
    if success then
        print("âœ… Module required successfully: %s")
        print("Type:", type(result))
        if type(result) == "table" then
            print("Keys:", table.concat(result, ", "))
        end
        -- Module result is stored in 'result' variable
    else
        warn("âŒ Failed to require: " .. tostring(result))
    end
else
    warn("âŒ ModuleScript not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name)

    elseif item.Type == "RemoteEvent" then
        scriptCode = string.format([[
-- ğŸ“¡ REMOTE EVENT FIRE
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("RemoteEvent") then
    -- Configuration - Edit these values
    local args = {
        -- Add your arguments here
        -- "arg1",
        -- 123,
        -- true
    }
    
    print("ğŸ”¥ Firing RemoteEvent: %s")
    current:FireServer(unpack(args))
    print("âœ… RemoteEvent fired!")
else
    warn("âŒ RemoteEvent not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name)

    elseif item.Type == "RemoteFunction" then
        scriptCode = string.format([[
-- ğŸ“ REMOTE FUNCTION INVOKE
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("RemoteFunction") then
    -- Configuration - Edit these values
    local args = {
        -- Add your arguments here
        -- "arg1",
        -- 123,
    }
    
    print("ğŸ“ Invoking RemoteFunction: %s")
    local success, result = pcall(function()
        return current:InvokeServer(unpack(args))
    end)
    
    if success then
        print("âœ… Result:", result)
    else
        warn("âŒ Error:", result)
    end
else
    warn("âŒ RemoteFunction not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name)

    elseif item.Type == "UnreliableRemoteEvent" then
        scriptCode = string.format([[
-- ğŸ“¶ UNRELIABLE REMOTE EVENT
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("UnreliableRemoteEvent") then
    local args = {}
    
    print("ğŸ”¥ Firing UnreliableRemoteEvent: %s")
    current:FireServer(unpack(args))
    print("âœ… Fired!")
else
    warn("âŒ Not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name)

    elseif item.Type == "BindableEvent" then
        scriptCode = string.format([[
-- ğŸ”— BINDABLE EVENT FIRE
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("BindableEvent") then
    local args = {}
    
    print("ğŸ”¥ Firing BindableEvent: %s")
    current:Fire(unpack(args))
    print("âœ… Fired!")
else
    warn("âŒ Not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name)

    elseif item.Type == "BindableFunction" then
        scriptCode = string.format([[
-- âš™ï¸ BINDABLE FUNCTION INVOKE
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("BindableFunction") then
    local args = {}
    
    print("âš™ï¸ Invoking BindableFunction: %s")
    local result = current:Invoke(unpack(args))
    print("âœ… Result:", result)
else
    warn("âŒ Not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name)

    elseif item.Type == "Sound" then
        scriptCode = string.format([[
-- ğŸ”Š SOUND CONTROL
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("Sound") then
    -- Sound controls
    if current.Playing then
        current:Stop()
        print("â¹ï¸ Sound stopped: %s")
    else
        current:Play()
        print("â–¶ï¸ Sound playing: %s")
    end
    
    -- You can also modify:
    -- current.Volume = 1
    -- current.PlaybackSpeed = 1
    -- current.Looped = true
else
    warn("âŒ Sound not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name, item.Name)

    elseif item.Type == "Animator" then
        scriptCode = string.format([[
-- ğŸ¬ ANIMATOR CONTROL
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("Animator") then
    -- Get playing animations
    local tracks = current:GetPlayingAnimationTracks()
    print("ğŸ¬ Playing animations:", #tracks)
    
    for _, track in ipairs(tracks) do
        print("  - " .. track.Name .. " (Speed: " .. track.Speed .. ")")
        -- track:Stop() -- Uncomment to stop
        -- track:AdjustSpeed(2) -- Speed up
    end
else
    warn("âŒ Animator not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name)

    elseif item.Type == "Animation" then
        scriptCode = string.format([[
-- ğŸï¸ ANIMATION PLAY
-- Target: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current and current:IsA("Animation") then
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local animator = humanoid:FindFirstChildOfClass("Animator")
            if animator then
                local track = animator:LoadAnimation(current)
                track:Play()
                print("â–¶ï¸ Playing animation: %s")
            end
        end
    end
else
    warn("âŒ Animation not found: %s")
end
]], item.Name, item.Path, item.Path, item.Name, item.Name)

    else
        -- Generic constraint/object script
        scriptCode = string.format([[
-- ğŸ”§ OBJECT INFO & CONTROL
-- Target: %s
-- Type: %s
-- Path: %s

local path = "%s"
local pathParts = string.split(path, ".")
local current = game

for _, part in ipairs(pathParts) do
    if current then current = current:FindFirstChild(part) end
end

if current then
    print("âœ… Found: %s")
    print("Type:", current.ClassName)
    print("Parent:", current.Parent and current.Parent.Name or "nil")
    
    -- Print properties
    for _, prop in ipairs({"Enabled", "Visible", "Anchored", "CanCollide"}) do
        pcall(function()
            print(prop .. ":", current[prop])
        end)
    end
    
    -- Destroy object (uncomment to use)
    -- current:Destroy()
    -- print("ğŸ—‘ï¸ Destroyed!")
else
    warn("âŒ Object not found: %s")
end
]], item.Name, item.Type, item.Path, item.Path, item.Name, item.Name)
    end
    
    return scriptCode
end

local function CreateDeepScanCard(parent, item)
    -- Generate script code for this item
    item.Code = GenerateDeepScanScript(item)
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, math.floor(110 * guiScale))
    frame.BackgroundColor3 = Color3.fromRGB(35, 30, 45)
    frame.BorderSizePixel = 0
    frame.ZIndex = 3
    frame.Parent = parent
    
    local frameCorner = Instance.new("UICorner")
    frameCorner.CornerRadius = UDim.new(0, 8)
    frameCorner.Parent = frame
    
    local border = Instance.new("UIStroke")
    border.Color = Color3.fromRGB(120, 80, 180)
    border.Thickness = 1
    border.Parent = frame
    
    local icon = Instance.new("TextLabel")
    icon.Size = UDim2.new(0, math.floor(30 * guiScale), 0, math.floor(30 * guiScale))
    icon.Position = UDim2.new(0, 5, 0, 5)
    icon.BackgroundColor3 = Color3.fromRGB(50, 40, 60)
    icon.Text = item.Icon or "ğŸ“¦"
    icon.TextSize = math.floor(14 * guiScale)
    icon.ZIndex = 4
    icon.Parent = frame
    
    local iconCorner = Instance.new("UICorner")
    iconCorner.CornerRadius = UDim.new(0, 6)
    iconCorner.Parent = icon
    
    local name = Instance.new("TextLabel")
    name.Size = UDim2.new(1, -math.floor(45 * guiScale), 0, math.floor(16 * guiScale))
    name.Position = UDim2.new(0, math.floor(40 * guiScale), 0, 5)
    name.BackgroundTransparency = 1
    name.Text = item.Name
    name.TextColor3 = Color3.fromRGB(180, 150, 220)
    name.TextSize = math.floor(11 * guiScale)
    name.Font = Enum.Font.GothamBold
    name.TextXAlignment = Enum.TextXAlignment.Left
    name.TextTruncate = Enum.TextTruncate.AtEnd
    name.ZIndex = 4
    name.Parent = frame
    
    local typeLabel = Instance.new("TextLabel")
    typeLabel.Size = UDim2.new(1, -math.floor(45 * guiScale), 0, math.floor(14 * guiScale))
    typeLabel.Position = UDim2.new(0, math.floor(40 * guiScale), 0, 22)
    typeLabel.BackgroundTransparency = 1
    typeLabel.Text = "ğŸ“‚ " .. item.Type
    typeLabel.TextColor3 = Color3.fromRGB(140, 140, 160)
    typeLabel.TextSize = math.floor(9 * guiScale)
    typeLabel.Font = Enum.Font.Gotham
    typeLabel.TextXAlignment = Enum.TextXAlignment.Left
    typeLabel.ZIndex = 4
    typeLabel.Parent = frame
    
    local desc = Instance.new("TextLabel")
    desc.Size = UDim2.new(1, -math.floor(45 * guiScale), 0, math.floor(14 * guiScale))
    desc.Position = UDim2.new(0, math.floor(40 * guiScale), 0, 38)
    desc.BackgroundTransparency = 1
    desc.Text = item.Description or ""
    desc.TextColor3 = Color3.fromRGB(160, 160, 180)
    desc.TextSize = math.floor(9 * guiScale)
    desc.Font = Enum.Font.Gotham
    desc.TextXAlignment = Enum.TextXAlignment.Left
    desc.TextTruncate = Enum.TextTruncate.AtEnd
    desc.ZIndex = 4
    desc.Parent = frame
    
    -- Button container
    local btnFrame = Instance.new("Frame")
    btnFrame.Size = UDim2.new(1, -10, 0, math.floor(30 * guiScale))
    btnFrame.Position = UDim2.new(0, 5, 1, -math.floor(35 * guiScale))
    btnFrame.BackgroundTransparency = 1
    btnFrame.ZIndex = 4
    btnFrame.Parent = frame
    
    -- Execute button
    local execBtn = Instance.new("TextButton")
    execBtn.Size = UDim2.new(0, math.floor(80 * guiScale), 1, 0)
    execBtn.Position = UDim2.new(0, 0, 0, 0)
    execBtn.BackgroundColor3 = Color3.fromRGB(100, 60, 160)
    execBtn.Text = "â–¶ï¸ EXEC"
    execBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    execBtn.TextSize = math.floor(9 * guiScale)
    execBtn.Font = Enum.Font.GothamBold
    execBtn.ZIndex = 5
    execBtn.Parent = btnFrame
    
    local execCorner = Instance.new("UICorner")
    execCorner.CornerRadius = UDim.new(0, 4)
    execCorner.Parent = execBtn
    
    execBtn.MouseButton1Click:Connect(function()
        Analyzer:Notify("â–¶ï¸ Execute", "Running " .. item.Name)
        spawn(function()
            local success, err = pcall(function()
                loadstring(item.Code)()
            end)
            if not success then
                Analyzer:Notify("âŒ Error", "Check console")
                print("Error:", err)
            end
        end)
    end)
    
    -- Copy Script button
    local copyScriptBtn = Instance.new("TextButton")
    copyScriptBtn.Size = UDim2.new(0, math.floor(80 * guiScale), 1, 0)
    copyScriptBtn.Position = UDim2.new(0, math.floor(85 * guiScale), 0, 0)
    copyScriptBtn.BackgroundColor3 = Color3.fromRGB(80, 100, 160)
    copyScriptBtn.Text = "ğŸ“‹ COPY"
    copyScriptBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    copyScriptBtn.TextSize = math.floor(9 * guiScale)
    copyScriptBtn.Font = Enum.Font.GothamBold
    copyScriptBtn.ZIndex = 5
    copyScriptBtn.Parent = btnFrame
    
    local copyScriptCorner = Instance.new("UICorner")
    copyScriptCorner.CornerRadius = UDim.new(0, 4)
    copyScriptCorner.Parent = copyScriptBtn
    
    copyScriptBtn.MouseButton1Click:Connect(function()
        setclipboard(item.Code)
        Analyzer:Notify("ğŸ“‹ Copied", item.Name .. " script copied!")
    end)
    
    -- Edit Script button
    local editBtn = Instance.new("TextButton")
    editBtn.Size = UDim2.new(0, math.floor(80 * guiScale), 1, 0)
    editBtn.Position = UDim2.new(0, math.floor(170 * guiScale), 0, 0)
    editBtn.BackgroundColor3 = Color3.fromRGB(180, 120, 60)
    editBtn.Text = "âœï¸ EDIT"
    editBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    editBtn.TextSize = math.floor(9 * guiScale)
    editBtn.Font = Enum.Font.GothamBold
    editBtn.ZIndex = 5
    editBtn.Parent = btnFrame
    
    local editCorner = Instance.new("UICorner")
    editCorner.CornerRadius = UDim.new(0, 4)
    editCorner.Parent = editBtn
    
    editBtn.MouseButton1Click:Connect(function()
        GUI_OpenScriptEditor(item)
    end)
    
    -- Info button
    local infoBtn = Instance.new("TextButton")
    infoBtn.Size = UDim2.new(0, math.floor(80 * guiScale), 1, 0)
    infoBtn.Position = UDim2.new(0, math.floor(255 * guiScale), 0, 0)
    infoBtn.BackgroundColor3 = Color3.fromRGB(100, 80, 120)
    infoBtn.Text = "â„¹ï¸ INFO"
    infoBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    infoBtn.TextSize = math.floor(9 * guiScale)
    infoBtn.Font = Enum.Font.GothamBold
    infoBtn.ZIndex = 5
    infoBtn.Parent = btnFrame
    
    local infoCorner = Instance.new("UICorner")
    infoCorner.CornerRadius = UDim.new(0, 4)
    infoCorner.Parent = infoBtn
    
    infoBtn.MouseButton1Click:Connect(function()
        Analyzer:Notify("â„¹ï¸ " .. item.Name, "Type: " .. item.Type .. "\nPath: " .. item.Path)
    end)
    
    return frame
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DASHBOARD TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local dashContent = tabContents["Dashboard"]

CreateSection(dashContent, "ğŸ® GAME INFO")

local gameInfoLabel = CreateLabel(dashContent, "Loading...", 60)

function GUI_UpdateGameInfo()
    gameInfoLabel.Text = string.format([[Game: %s
Place ID: %d
Genre: %s]], 
        Analyzer.GameInfo.Name,
        Analyzer.GameInfo.PlaceId,
        Analyzer.GameInfo.Genre
    )
end

CreateSection(dashContent, "ğŸ” SCANNER")

CreateButton(dashContent, "ğŸš€ START SMART SCAN", Color3.fromRGB(60, 120, 220), function()
    if not Analyzer.IsScanning then
        Analyzer:StartScan()
    end
end)

local progressLabel = CreateLabel(dashContent, "Ready to scan", 20)
local progressBar = Instance.new("Frame")
progressBar.Size = UDim2.new(1, 0, 0, math.floor(8 * guiScale))
progressBar.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
progressBar.BorderSizePixel = 0
progressBar.ZIndex = 3
progressBar.Parent = dashContent

local progressBarCorner = Instance.new("UICorner")
progressBarCorner.CornerRadius = UDim.new(0, 4)
progressBarCorner.Parent = progressBar

local progressFill = Instance.new("Frame")
progressFill.Size = UDim2.new(0, 0, 1, 0)
progressFill.BackgroundColor3 = Color3.fromRGB(100, 180, 255)
progressFill.BorderSizePixel = 0
progressFill.ZIndex = 4
progressFill.Parent = progressBar

local progressFillCorner = Instance.new("UICorner")
progressFillCorner.CornerRadius = UDim.new(0, 4)
progressFillCorner.Parent = progressFill

function GUI_UpdateProgress(current, total)
    if total == 0 then return end
    local percent = (current / total) * 100
    progressLabel.Text = string.format("Scanning: %d/%d (%.1f%%)", current, total, percent)
    progressFill.Size = UDim2.new(percent / 100, 0, 1, 0)
end

CreateSection(dashContent, "ğŸ“Š RESULTS")

local resultsLabel = CreateLabel(dashContent, "Start scan to see results", 100)

function GUI_UpdateResults()
    -- Calculate Deep Scan totals
    local deepTotal = 0
    if Analyzer.DeepScan then
        for _, items in pairs(Analyzer.DeepScan) do
            if type(items) == "table" then
                deepTotal = deepTotal + #items
            end
        end
    end
    
    resultsLabel.Text = string.format([[â±ï¸ Duration: %ds | ğŸ“¦ Scanned: %d

ğŸ’¯ LOCAL EXPLOITS: %d (100%% WORK)
   âœ… Editable Values
   âœ… Direct modification
   âœ… Guaranteed success

ğŸ¤– AUTOMATION: %d (100%% WORK)
   âœ… Auto-clickers
   âœ… Auto-prompts
   âœ… Farming loops

ğŸ” DEEP SCAN: %d (ADVANCED)
   ğŸ“œ Scripts & Modules
   ğŸ“¡ Remote Communication
   ğŸ”§ Constraints & Physics

âš ï¸ REMOTE: %d (ADVANCED)
   âš ï¸ Needs parameters
   âš ï¸ Server validation
   âš ï¸ May not work]], 
        math.floor(Analyzer.ScanData.Duration),
        Analyzer.ScanData.Scanned,
        #Analyzer.Exploits.Local,
        #Analyzer.Exploits.Automation,
        deepTotal,
        #Analyzer.Exploits.Remote
    )
    
    GUI_UpdateAllTabs()
end

CreateSection(dashContent, "âš¡ QUICK ACTIONS")

CreateButton(dashContent, "â¹ï¸ STOP ALL LOOPS", Color3.fromRGB(200, 60, 60), function()
    Analyzer:StopAll()
end)

CreateLabel(dashContent, [[
â„¹ï¸ HOW TO USE:

ğŸ’¯ LOCAL Tab:
- ALL value types processed
- ğŸŸ¢ GREEN = Edit directly
- ğŸŸ  ORANGE = Try inject
- Smart input based on type

ğŸ¤– AUTO Tab:
- Auto-click & auto-prompt
- START LOOP to farm
- ğŸ“‹ COPY script code
- âœï¸ EDIT before running

ğŸ§  AI Tab:
- AI-generated smart bots
- Auto fishing/farming/mining
- Pattern-based automation

ğŸ” DEEP Tab (NEW!):
- Scripts & ModuleScripts
- Remote communications
- Physics & constraints
- Animation & sound

âš ï¸ REMOTE Tab:
- Advanced users only
]], 340)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UPDATE ALL TABS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function GUI_UpdateAllTabs()
    -- Clear all tabs
    for _, tabName in ipairs({"ğŸ’¯Local", "ğŸ¤–Auto", "ğŸ§ AI", "ğŸ”Deep", "âš ï¸Remote"}) do
        local content = tabContents[tabName]
        if content then
            for _, child in ipairs(content:GetChildren()) do
                if child:IsA("Frame") or child:IsA("TextLabel") then
                    child:Destroy()
                end
            end
        end
    end
    
    -- Update Local Tab
    local localContent = tabContents["ğŸ’¯Local"]
    CreateSection(localContent, "ğŸ’¯ LOCAL EXPLOITS (" .. #Analyzer.Exploits.Local .. ") - 100% WORK")
    
    if #Analyzer.Exploits.Local == 0 then
        CreateLabel(localContent, "No local exploits found.\nThese are values that can affect gameplay.", 50)
    else
        CreateLabel(localContent, [[âœ… ALL VALUE TYPES - Guaranteed Processing!

ğŸŸ¢ GREEN = Editable (can modify)
ğŸŸ  ORANGE = Injectable (try inject)
ğŸ”´ RED = Read-Only (info only)

INPUT TYPES:
â€¢ Numbers â†’ Number input box
â€¢ Text â†’ Text input box
â€¢ True/False â†’ Toggle buttons
â€¢ Others â†’ Inject/Info button

All values affect gameplay!]], 110)
        
        for _, exploit in ipairs(Analyzer.Exploits.Local) do
            CreateLocalExploitCard(localContent, exploit)
        end
    end
    
    -- Update Automation Tab
    local autoContent = tabContents["ğŸ¤–Auto"]
    CreateSection(autoContent, "ğŸ¤– AUTOMATION (" .. #Analyzer.Exploits.Automation .. ") - 100% WORK")
    
    if #Analyzer.Exploits.Automation == 0 then
        CreateLabel(autoContent, "No automation exploits found.\nThese are auto-clickers and auto-prompts.", 50)
    else
        CreateLabel(autoContent, [[âœ… Click START LOOP to auto-farm!
ğŸ“‹ COPY SCRIPT to get the code
âœï¸ EDIT SCRIPT to modify before run
Click STOP to end the loop.]], 60)
        
        for _, exploit in ipairs(Analyzer.Exploits.Automation) do
            CreateAutoExploitCard(autoContent, exploit)
        end
    end
    
    -- Update AI Scripts Tab (NEW!)
    local aiContent = tabContents["ğŸ§ AI"]
    
    -- Safety check
    if not Analyzer.SmartScripts then
        Analyzer.SmartScripts = {}
    end
    
    CreateSection(aiContent, "ğŸ§  AI SMART SCRIPTS (" .. #Analyzer.SmartScripts .. ") - AUTO-GENERATED")
    
    if #Analyzer.SmartScripts == 0 then
        CreateLabel(aiContent, [[No smart scripts generated yet.

AI will analyze game patterns and create:
ğŸ£ Fishing Bots
ğŸŒ¾ Farming Bots
â›ï¸ Mining Bots
ğŸ”„ Universal Auto-Farm
ğŸ Reward Claimers

Run a scan to generate!]], 100)
    else
        CreateLabel(aiContent, [[ğŸ§  AI-GENERATED AUTOMATION

These scripts were created by analyzing
game patterns and exploit chains.

Click RUN to execute the smart bot!
Click COPY to get the full script.]], 70)
        
        for _, script in ipairs(Analyzer.SmartScripts) do
            CreateAIScriptCard(aiContent, script)
        end
    end
    
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- Update Deep Scan Tab (NEW!)
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    local deepContent = tabContents["ğŸ”Deep"]
    if deepContent then
        -- Safety check
        if not Analyzer.DeepScan then
            Analyzer.DeepScan = {
                Scripts = {}, ServerServices = {}, RemoteCommunication = {},
                InstanceChanges = {}, Physics = {}, PlayerManagement = {},
                Security = {}, WorldState = {}, AnimationSound = {},
                Constraints = {}, Collections = {}, GlobalState = {}
            }
        end
        
        -- Calculate totals
        local totalDeep = 0
        for category, items in pairs(Analyzer.DeepScan) do
            if type(items) == "table" then
                totalDeep = totalDeep + #items
            end
        end
        
        CreateSection(deepContent, "ğŸ” DEEP SCAN RESULTS (" .. totalDeep .. ") - ADVANCED ANALYSIS")
        
        if totalDeep == 0 then
            CreateLabel(deepContent, [[No deep scan results yet.

Deep Scan detects:
ğŸ“œ Scripts & ModuleScripts
ğŸ“¡ Remote Communication
ğŸ”§ Physics Constraints
ğŸ¬ Animation & Sound
ğŸ† World State
âš™ï¸ And much more!

Run a scan to analyze!]], 120)
        else
            CreateLabel(deepContent, [[ğŸ” ADVANCED OBJECT DETECTION

Deep scan reveals game internals:
â€¢ Script architecture
â€¢ Remote communications
â€¢ Physics systems
â€¢ Audio/Visual elements

Use this info for advanced exploits!]], 80)
            
            -- Scripts Section
            if #Analyzer.DeepScan.Scripts > 0 then
                CreateSection(deepContent, "ğŸ“œ SCRIPTS (" .. #Analyzer.DeepScan.Scripts .. ")")
                for _, item in ipairs(Analyzer.DeepScan.Scripts) do
                    CreateDeepScanCard(deepContent, item)
                end
            end
            
            -- Remote Communication Section
            if #Analyzer.DeepScan.RemoteCommunication > 0 then
                CreateSection(deepContent, "ğŸ“¡ REMOTE COMMUNICATION (" .. #Analyzer.DeepScan.RemoteCommunication .. ")")
                for _, item in ipairs(Analyzer.DeepScan.RemoteCommunication) do
                    CreateDeepScanCard(deepContent, item)
                end
            end
            
            -- Constraints Section
            if #Analyzer.DeepScan.Constraints > 0 then
                CreateSection(deepContent, "ğŸ”§ CONSTRAINTS (" .. #Analyzer.DeepScan.Constraints .. ")")
                for _, item in ipairs(Analyzer.DeepScan.Constraints) do
                    CreateDeepScanCard(deepContent, item)
                end
            end
            
            -- Animation & Sound Section
            if #Analyzer.DeepScan.AnimationSound > 0 then
                CreateSection(deepContent, "ğŸ¬ ANIMATION & SOUND (" .. #Analyzer.DeepScan.AnimationSound .. ")")
                for _, item in ipairs(Analyzer.DeepScan.AnimationSound) do
                    CreateDeepScanCard(deepContent, item)
                end
            end
            
            -- World State Section
            if #Analyzer.DeepScan.WorldState > 0 then
                CreateSection(deepContent, "ğŸ† WORLD STATE (" .. #Analyzer.DeepScan.WorldState .. ")")
                for _, item in ipairs(Analyzer.DeepScan.WorldState) do
                    CreateDeepScanCard(deepContent, item)
                end
            end
        end
    end
    
    -- Update Remote Tab
    local remoteContent = tabContents["âš ï¸Remote"]
    CreateSection(remoteContent, "âš ï¸ REMOTE EXPLOITS (" .. #Analyzer.Exploits.Remote .. ") - ADVANCED")
    
    if #Analyzer.Exploits.Remote == 0 then
        CreateLabel(remoteContent, "No remote exploits found.\nThese require server communication.", 50)
    else
        CreateLabel(remoteContent, "âš ï¸ ADVANCED: These may NOT work without correct parameters!\nEnter values manually and test.", 50)
        
        for _, exploit in ipairs(Analyzer.Exploits.Remote) do
            CreateRemoteExploitCard(remoteContent, exploit)
        end
    end
end

-- Notification System
local notifFrame = Instance.new("Frame")
notifFrame.Size = UDim2.new(0, math.floor(280 * guiScale), 0, math.floor(70 * guiScale))
notifFrame.Position = UDim2.new(0.5, -math.floor(140 * guiScale), 0, -math.floor(80 * guiScale))
notifFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
notifFrame.BackgroundTransparency = 1
notifFrame.BorderSizePixel = 0
notifFrame.ZIndex = 100
notifFrame.Parent = ScreenGui

local notifCorner = Instance.new("UICorner")
notifCorner.CornerRadius = UDim.new(0, 12)
notifCorner.Parent = notifFrame

local notifTitle = Instance.new("TextLabel")
notifTitle.Size = UDim2.new(1, -10, 0, math.floor(28 * guiScale))
notifTitle.Position = UDim2.new(0, 5, 0, 5)
notifTitle.BackgroundTransparency = 1
notifTitle.Text = ""
notifTitle.TextColor3 = Color3.fromRGB(100, 180, 255)
notifTitle.TextSize = math.floor(13 * guiScale)
notifTitle.Font = Enum.Font.GothamBold
notifTitle.TextXAlignment = Enum.TextXAlignment.Left
notifTitle.ZIndex = 101
notifTitle.Parent = notifFrame

local notifText = Instance.new("TextLabel")
notifText.Size = UDim2.new(1, -10, 0, math.floor(30 * guiScale))
notifText.Position = UDim2.new(0, 5, 0, math.floor(33 * guiScale))
notifText.BackgroundTransparency = 1
notifText.Text = ""
notifText.TextColor3 = Color3.fromRGB(200, 200, 200)
notifText.TextSize = math.floor(11 * guiScale)
notifText.Font = Enum.Font.Gotham
notifText.TextWrapped = true
notifText.TextXAlignment = Enum.TextXAlignment.Left
notifText.TextYAlignment = Enum.TextYAlignment.Top
notifText.ZIndex = 101
notifText.Parent = notifFrame

function GUI_ShowNotification(title, text)
    notifTitle.Text = title
    notifText.Text = text
    
    Services.TweenService:Create(notifFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(0.5, -math.floor(140 * guiScale), 0, 10),
        BackgroundTransparency = 0
    }):Play()
    
    wait(3)
    
    Services.TweenService:Create(notifFrame, TweenInfo.new(0.3), {
        Position = UDim2.new(0.5, -math.floor(140 * guiScale), 0, -math.floor(80 * guiScale)),
        BackgroundTransparency = 1
    }):Play()
end

-- Initialize
print("\nâœ… GUI System loaded!")
print("ğŸ¨ Smart categorization ready!")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

Analyzer:DetectGame()
GUI_UpdateGameInfo()
SwitchTab("Dashboard")

wait(0.5)
Analyzer:Notify("âœ… Ready!", "Smart Analyzer v" .. version .. " loaded!")

end) -- End of pcall GUI creation

if not guiSuccess then
    warn("âŒ GUI ERROR:", guiError)
    warn("âŒ GUI failed to load! Please check the error above.")
else
    print("âœ… GUI loaded successfully!")
end

print("\nğŸš€ SMART GAME ANALYZER READY!")
print("ğŸ’¯ LOCAL = Guaranteed to work")
print("ğŸ¤– AUTO = Auto-farming loops")
print("ğŸ§  AI = Smart bots")
print("âš ï¸ REMOTE = Advanced only")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
